###############################################################################
#
# IAR C/C++ Compiler V9.30.3.3983 for 8051                20/Apr/2017  12:17:44
# Copyright 2004-2016 IAR Systems AB.
# Evaluation license - IAR Embedded Workbench for 8051, Evaluation version 9.30
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Components\hal\target\CC2530EB\hal_lcd.c
#    Command line       =  
#        -f
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0x0422
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)
#        -DREJOIN_POLL_RATE=440
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Components\hal\target\CC2530EB\hal_lcd.c
#        -D NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC
#        -D LCD_SUPPORTED=DEBUG -D xPOWER_SAVING -lC
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\EndDeviceEB\List
#        -lA
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\EndDeviceEB\List
#        --diag_suppress Pe001,Pa010 -o
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\EndDeviceEB\Obj
#        -e --no_code_motion --debug --core=plain --dptr=16,1
#        --data_model=large --code_model=banked
#        --calling_convention=xdata_reentrant --place_constants=data_rom
#        --nr_virtual_regs 16 -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\Source\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\ZMain\TI2530DB\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\hal\include\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\include\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\high_level\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mt\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\osal\include\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\services\saddr\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\services\sdata\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\af\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\nwk\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\sapi\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\sec\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\sys\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\zdo\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\zmac\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\zmac\f8w\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Components\hal\BME280_driver-master\
#        -Ohz --require_prototypes
#    List file          =  
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\EndDeviceEB\List\hal_lcd.lst
#    Object file        =  
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\EndDeviceEB\Obj\hal_lcd.r51
#
###############################################################################

C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Components\hal\target\CC2530EB\hal_lcd.c
      1          /**************************************************************************************************
      2            Filename:       hal_lcd.c
      3            Revised:        $Date: 2012-09-30 16:36:36 -0700 (Sun, 30 Sep 2012) $
      4            Revision:       $Revision: 31658 $
      5          
      6            Description:    This file contains the interface to the HAL LCD Service.
      7          
      8          
      9            Copyright 2007-2012 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License"). You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product. Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /**************************************************************************************************
     41           *                                           INCLUDES
     42           **************************************************************************************************/
     43          #include "hal_types.h"
     44          #include "hal_lcd.h"

   \                                 In  segment SFR_AN, at 0x86
   \   unsigned char volatile __sfr U0CSR
   \                     U0CSR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc1
   \   unsigned char volatile __sfr U0DBUF
   \                     U0DBUF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc2
   \   unsigned char volatile __sfr U0BAUD
   \                     U0BAUD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc5
   \   unsigned char volatile __sfr U0GCR
   \                     U0GCR:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1
     45          #include "OSAL.h"
     46          #include "OnBoard.h"
     47          #include "hal_assert.h"
     48          
     49          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
     50            #include "DebugTrace.h"
     51          #endif
     52          
     53          /**************************************************************************************************
     54           *                                          CONSTANTS
     55           **************************************************************************************************/
     56          /*
     57            LCD pins
     58          
     59            //control
     60            P0.0 - LCD_MODE
     61            P1.1 - LCD_FLASH_RESET
     62            P1.2 - LCD_CS
     63          
     64            //spi
     65            P1.5 - CLK
     66            P1.6 - MOSI
     67            P1.7 - MISO
     68          */
     69          
     70          /* LCD Control lines */
     71          #define HAL_LCD_MODE_PORT 0
     72          #define HAL_LCD_MODE_PIN  0
     73          
     74          #define HAL_LCD_RESET_PORT 1
     75          #define HAL_LCD_RESET_PIN  1
     76          
     77          #define HAL_LCD_CS_PORT 1
     78          #define HAL_LCD_CS_PIN  2
     79          
     80          /* LCD SPI lines */
     81          #define HAL_LCD_CLK_PORT 1
     82          #define HAL_LCD_CLK_PIN  5
     83          
     84          #define HAL_LCD_MOSI_PORT 1
     85          #define HAL_LCD_MOSI_PIN  6
     86          
     87          #define HAL_LCD_MISO_PORT 1
     88          #define HAL_LCD_MISO_PIN  7
     89          
     90          /* SPI settings */
     91          #define HAL_SPI_CLOCK_POL_LO       0x00
     92          #define HAL_SPI_CLOCK_PHA_0        0x00
     93          #define HAL_SPI_TRANSFER_MSB_FIRST 0x20
     94          
     95          /* LCD lines */
     96          #define LCD_MAX_LINE_COUNT              3
     97          
     98          /* Defines for HW LCD */
     99          
    100          /* Set power save mode */
    101          #define OSC_OFF                         0x00
    102          #define OSC_ON                          0x01
    103          #define POWER_SAVE_OFF                  0x00
    104          #define POWER_SAVE_ON                   0x02
    105          #define SET_POWER_SAVE_MODE(options)    HalLcd_HW_Control(0x0C | (options))
    106          
    107          /* Function Set */
    108          #define CGROM                           0x00
    109          #define CGRAM                           0x01
    110          #define COM_FORWARD                     0x00
    111          #define COM_BACKWARD                    0x02
    112          #define TWO_LINE                        0x00
    113          #define THREE_LINE                      0x04
    114          #define FUNCTION_SET(options)           HalLcd_HW_Control(0x10 | (options))
    115          
    116          /* Set Display Start Line */
    117          #define LINE1                           0x00
    118          #define LINE2                           0x01
    119          #define LINE3                           0x02
    120          #define LINE4                           0x03
    121          #define SET_DISPLAY_START_LINE(line)    HalLcd_HW_Control(0x18 | (line))
    122          
    123          /* Bias control */
    124          #define BIAS_1_5                        0x00
    125          #define BIAS_1_4                        0x01
    126          #define SET_BIAS_CTRL(bias)             HalLcd_HW_Control(0x1C | (bias))
    127          
    128          /* Power control */
    129          #define VOLTAGE_DIVIDER_OFF             0x00
    130          #define VOLTAGE_DIVIDER_ON              0x01
    131          #define CONVERTER_AND_REG_OFF           0x00
    132          #define CONVERTER_AND_REG_ON            0x04
    133          #define SET_POWER_CTRL(options)         HalLcd_HW_Control(0x20 | (options))
    134          
    135          // Set display control
    136          #define DISPLAY_CTRL_ON                 0x01
    137          #define DISPLAY_CTRL_OFF                0x00
    138          #define DISPLAY_CTRL_BLINK_ON           0x02
    139          #define DISPLAY_CTRL_BLINK_OFF          0x00
    140          #define DISPLAY_CTRL_CURSOR_ON          0x04
    141          #define DISPLAY_CTRL_CURSOR_OFF         0x00
    142          #define SET_DISPLAY_CTRL(options)       HalLcd_HW_Control(0x28 | (options))
    143          
    144          /* Set DD/ CGRAM address */
    145          #define SET_DDRAM_ADDR(charIndex)       HalLcd_HW_Control(0x80 | (charIndex))
    146          #define SET_GCRAM_CHAR(specIndex)       HalLcd_HW_Control(0xC0 | (specIndex))
    147          
    148          /* Set ICONRAM address */
    149          #define CONTRAST_CTRL_REGISTER          0x10
    150          #define SET_ICONRAM_ADDR(addr)          HalLcd_HW_Control(0x40 | (addr))
    151          
    152          /* Set double height */
    153          #define LINE_1_AND_2                    0x01
    154          #define LINE_2_AND_3                    0x02
    155          #define NORMAL_DISPLAY                  0x00
    156          #define SET_DOUBLE_HEIGHT(options)      HalLcd_HW_Control(0x08 | (options))
    157          
    158          /**************************************************************************************************
    159           *                                           MACROS
    160           **************************************************************************************************/
    161          
    162          #define HAL_IO_SET(port, pin, val)        HAL_IO_SET_PREP(port, pin, val)
    163          #define HAL_IO_SET_PREP(port, pin, val)   st( P##port##_##pin## = val; )
    164          
    165          #define HAL_CONFIG_IO_OUTPUT(port, pin, val)      HAL_CONFIG_IO_OUTPUT_PREP(port, pin, val)
    166          #define HAL_CONFIG_IO_OUTPUT_PREP(port, pin, val) st( P##port##SEL &= ~BV(pin); \
    167                                                                P##port##_##pin## = val; \
    168                                                                P##port##DIR |= BV(pin); )
    169          
    170          #define HAL_CONFIG_IO_PERIPHERAL(port, pin)      HAL_CONFIG_IO_PERIPHERAL_PREP(port, pin)
    171          #define HAL_CONFIG_IO_PERIPHERAL_PREP(port, pin) st( P##port##SEL |= BV(pin); )
    172          
    173          
    174          
    175          /* SPI interface control */
    176          #define LCD_SPI_BEGIN()     HAL_IO_SET(HAL_LCD_CS_PORT,  HAL_LCD_CS_PIN,  0); /* chip select */
    177          #define LCD_SPI_END()                                                         \
    178          {                                                                             \
    179            asm("NOP");                                                                 \
    180            asm("NOP");                                                                 \
    181            asm("NOP");                                                                 \
    182            asm("NOP");                                                                 \
    183            HAL_IO_SET(HAL_LCD_CS_PORT,  HAL_LCD_CS_PIN,  1); /* chip select */         \
    184          }
    185          /* clear the received and transmit byte status, write tx data to buffer, wait till transmit done */
    186          #define LCD_SPI_TX(x)                   { U1CSR &= ~(BV(2) | BV(1)); U1DBUF = x; while( !(U1CSR & BV(1)) ); }
    187          #define LCD_SPI_WAIT_RXRDY()            { while(!(U1CSR & BV(1))); }
    188          
    189          
    190          /* Control macros */
    191          #define LCD_DO_WRITE()        HAL_IO_SET(HAL_LCD_MODE_PORT,  HAL_LCD_MODE_PIN,  1);
    192          #define LCD_DO_CONTROL()      HAL_IO_SET(HAL_LCD_MODE_PORT,  HAL_LCD_MODE_PIN,  0);
    193          
    194          #define LCD_ACTIVATE_RESET()  HAL_IO_SET(HAL_LCD_RESET_PORT, HAL_LCD_RESET_PIN, 0);
    195          #define LCD_RELEASE_RESET()   HAL_IO_SET(HAL_LCD_RESET_PORT, HAL_LCD_RESET_PIN, 1);
    196          
    197          #if (HAL_LCD == TRUE)
    198          /**************************************************************************************************
    199           *                                       LOCAL VARIABLES
    200           **************************************************************************************************/
    201          
    202          static uint8 *Lcd_Line1;
    203          
    204          /**************************************************************************************************
    205           *                                       FUNCTIONS - API
    206           **************************************************************************************************/
    207          
    208          void HalLcd_HW_Init(void);
    209          void HalLcd_HW_WaitUs(uint16 i);
    210          void HalLcd_HW_Clear(void);
    211          void HalLcd_HW_ClearAllSpecChars(void);
    212          void HalLcd_HW_Control(uint8 cmd);
    213          void HalLcd_HW_Write(uint8 data);
    214          void HalLcd_HW_SetContrast(uint8 value);
    215          void HalLcd_HW_WriteChar(uint8 line, uint8 col, char text);
    216          void HalLcd_HW_WriteLine(uint8 line, const char *pText);
    217          #endif //LCD
    218          
    219          /**************************************************************************************************
    220           * @fn      HalLcdInit
    221           *
    222           * @brief   Initilize LCD Service
    223           *
    224           * @param   init - pointer to void that contains the initialized value
    225           *
    226           * @return  None
    227           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    228          void HalLcdInit(void)
   \                     HalLcdInit:
    229          { 
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    230            
    231            HalLcd_HW_Init();
   \   000004                ; Setup parameters for call to function HalLcd_HW_Init
   \   000004   12....       LCALL   `??HalLcd_HW_Init::?relay`; Banked call to: HalLcd_HW_Init
    232          
    233          /*
    234          #if (HAL_LCD == TRUE)
    235            Lcd_Line1 = NULL;
    236           
    237          #endif
    238            
    239            */
    240          }
   \   000007   D083         POP     DPH
   \   000009   D082         POP     DPL
   \   00000B   02....       LJMP    ?BRET
    241          
    242          /*************************************************************************************************
    243           *                    LCD EMULATION FUNCTIONS
    244           *
    245           * Some evaluation boards are equipped with Liquid Crystal Displays
    246           * (LCD) which may be used to display diagnostic information. These
    247           * functions provide LCD emulation, sending the diagnostic strings
    248           * to Z-Tool via the RS232 serial port. These functions are enabled
    249           * when the "LCD_SUPPORTED" compiler flag is placed in the makefile.
    250           *
    251           * Most applications update both lines (1 and 2) of the LCD whenever
    252           * text is posted to the device. This emulator assumes that line 1 is
    253           * updated first (saved locally) and the formatting and send operation
    254           * is triggered by receipt of line 2. Nothing will be transmitted if
    255           * only line 1 is updated.
    256           *
    257           *************************************************************************************************/
    258          
    259          
    260          /**************************************************************************************************
    261           * @fn      HalLcdWriteString
    262           *
    263           * @brief   Write a string to the LCD
    264           *
    265           * @param   str    - pointer to the string that will be displayed
    266           *          option - display options
    267           *
    268           * @return  None
    269           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    270          void HalLcdWriteString ( char *str, uint8 option)
   \                     HalLcdWriteString:
    271          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    272          #if (HAL_LCD == TRUE)
    273          
    274            uint8 strLen = 0;
                         ^
Warning[Pe177]: variable "strLen" was declared but never referenced
    275            uint8 totalLen = 0;
                         ^
Warning[Pe177]: variable "totalLen" was declared but never referenced
    276            uint8 *buf;
                          ^
Warning[Pe177]: variable "buf" was declared but never referenced
    277            uint8 tmpLen;
                         ^
Warning[Pe177]: variable "tmpLen" was declared but never referenced

  static uint8 *Lcd_Line1;
                ^
"C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Components\hal\target\CC2530EB\hal_lcd.c",202  Warning[Pe177]: 
          variable "Lcd_Line1" was declared but never referenced
    278          
    279          #endif 
    280            
    281            uint8 i = 0;
   \   000009   75..00       MOV     ?V0,#0x0
   \   00000C   8006         SJMP    ??HalLcdWriteString_0
    282            
    283            
    284            while(*(str + i) != '\0')
    285            {
    286              HalLcd_HW_Write(*(str + i++));
   \                     ??HalLcdWriteString_1:
   \   00000E                ; Setup parameters for call to function HalLcd_HW_Write
   \   00000E   F9           MOV     R1,A
   \   00000F   12....       LCALL   `??HalLcd_HW_Write::?relay`; Banked call to: HalLcd_HW_Write
   \   000012   05..         INC     ?V0
    287            }
   \                     ??HalLcdWriteString_0:
   \   000014   A8..         MOV     R0,?V0
   \   000016   EE           MOV     A,R6
   \   000017   28           ADD     A,R0
   \   000018   F582         MOV     DPL,A
   \   00001A   E4           CLR     A
   \   00001B   3F           ADDC    A,R7
   \   00001C   F583         MOV     DPH,A
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   70ED         JNZ     ??HalLcdWriteString_1
    288            
    289            HalLcd_HW_Write(10);
   \   000021                ; Setup parameters for call to function HalLcd_HW_Write
   \   000021   790A         MOV     R1,#0xa
   \   000023                REQUIRE ?Subroutine0
   \   000023                ; // Fall through to label ?Subroutine0
    290            
    291           /*
    292            if ( Lcd_Line1 == NULL )
    293            {
    294              Lcd_Line1 = osal_mem_alloc( HAL_LCD_MAX_CHARS+1 );
    295              HalLcdWriteString( "TexasInstruments", 1 );
    296            }
    297          
    298            strLen = (uint8)osal_strlen( (char*)str );
    299          
    300            // Check boundries 
    301            if ( strLen > HAL_LCD_MAX_CHARS )
    302              strLen = HAL_LCD_MAX_CHARS;
    303          
    304            if ( option == HAL_LCD_LINE_1 )
    305            {
    306              // Line 1 gets saved for later 
    307              osal_memcpy( Lcd_Line1, str, strLen );
    308              Lcd_Line1[strLen] = '\0';
    309            }
    310            else
    311            {
    312              // Line 2 triggers action 
    313              tmpLen = (uint8)osal_strlen( (char*)Lcd_Line1 );
    314              totalLen =  tmpLen + 1 + strLen + 1;
    315              buf = osal_mem_alloc( totalLen );
    316              if ( buf != NULL )
    317              {
    318                // Concatenate strings 
    319                osal_memcpy( buf, Lcd_Line1, tmpLen );
    320                buf[tmpLen++] = ' ';
    321                osal_memcpy( &buf[tmpLen], str, strLen );
    322                buf[tmpLen+strLen] = '\0';
    323          
    324                // Send it out 
    325          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    326          
    327          #if defined(SERIAL_DEBUG_SUPPORTED)
    328                debug_str( (uint8*)buf );
    329          #endif //LCD_SUPPORTED
    330          
    331          #endif //ZTOOL_P1
    332          
    333                // Free mem 
    334                osal_mem_free( buf );
    335              }
    336            }
    337          
    338            // Display the string 
    339            HalLcd_HW_WriteLine (option, str);
    340          
    341          #endif //HAL_LCD
    342          */
    343            
    344          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL   `??HalLcd_HW_Write::?relay`; Banked call to: HalLcd_HW_Write
   \   000003   7F01         MOV     R7,#0x1
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA
    345          
    346          /**************************************************************************************************
    347           * @fn      HalLcdWriteValue
    348           *
    349           * @brief   Write a value to the LCD
    350           *
    351           * @param   value  - value that will be displayed
    352           *          radix  - 8, 10, 16
    353           *          option - display options
    354           *
    355           * @return  None
    356           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    357          void HalLcdWriteValue ( uint32 value, const uint8 radix, uint8 option)
   \                     HalLcdWriteValue:
    358          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 25
   \   000005   74E7         MOV     A,#-0x19
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
    359            
    360          #if (HAL_LCD == TRUE)
    361            uint8 buf[HAL_LCD_MAX_BUFF];
    362          
    363            _ltoa( value, &buf[0], radix );
   \   00000C                ; Setup parameters for call to function _ltoa
   \   00000C   A8..         MOV     R0,?XSP + 0
   \   00000E   A9..         MOV     R1,?XSP + 1
   \   000010   88..         MOV     ?V4,R0
   \   000012   89..         MOV     ?V5,R1
   \   000014   78..         MOV     R0,#?V4
   \   000016   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000019   EE           MOV     A,R6
   \   00001A   F9           MOV     R1,A
   \   00001B   12....       LCALL   `??_ltoa::?relay`    ; Banked call to: _ltoa
   \   00001E   7402         MOV     A,#0x2
   \   000020   12....       LCALL   ?DEALLOC_XSTACK8
    364            HalLcdWriteString( (char*)buf, option );
   \   000023                ; Setup parameters for call to function HalLcdWriteString
   \   000023   7427         MOV     A,#0x27
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   00002B   12....       LCALL   `??HalLcdWriteString::?relay`; Banked call to: HalLcdWriteString
    365          #endif
    366          }
   \   00002E   7419         MOV     A,#0x19
   \   000030   12....       LCALL   ?DEALLOC_XSTACK8
   \   000033   7F06         MOV     R7,#0x6
   \   000035   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F9           MOV     R1,A
   \   000002   AA..         MOV     R2,?XSP + 0
   \   000004   AB..         MOV     R3,?XSP + 1
   \   000006   22           RET
    367          
    368          /**************************************************************************************************
    369           * @fn      HalLcdWriteScreen
    370           *
    371           * @brief   Write a value to the LCD
    372           *
    373           * @param   line1  - string that will be displayed on line 1
    374           *          line2  - string that will be displayed on line 2
    375           *
    376           * @return  None
    377           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    378          void HalLcdWriteScreen( char *line1, char *line2 )
   \                     HalLcdWriteScreen:
    379          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    380            /*
    381          #if (HAL_LCD == TRUE)
    382            HalLcdWriteString( line1, 1 );
    383            HalLcdWriteString( line2, 2 );
    384          #endif
    385            */
    386          }
   \   000000   02....       LJMP    ?BRET
    387          
    388          /**************************************************************************************************
    389           * @fn      HalLcdWriteStringValue
    390           *
    391           * @brief   Write a string followed by a value to the LCD
    392           *
    393           * @param   title  - Title that will be displayed before the value
    394           *          value  - value
    395           *          format - redix
    396           *          line   - line number
    397           *
    398           * @return  None
    399           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    400          void HalLcdWriteStringValue( char *title, uint16 value, uint8 format, uint8 line )
   \                     HalLcdWriteStringValue:
    401          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 25
   \   000005   74E7         MOV     A,#-0x19
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V2,R4
   \   000010   8D..         MOV     ?V3,R5
   \   000012   89..         MOV     ?V0,R1
    402            uint8 tmpLen;
    403            uint8 buf[HAL_LCD_MAX_BUFF];
    404            uint32 err;
    405          
    406            tmpLen = (uint8)osal_strlen( (char*)title );
   \   000014                ; Setup parameters for call to function osal_strlen
   \   000014   12....       LCALL   `??osal_strlen::?relay`; Banked call to: osal_strlen
   \   000017   EA           MOV     A,R2
   \   000018   F5..         MOV     ?V1,A
    407            osal_memcpy( buf, title, tmpLen );
   \   00001A                ; Setup parameters for call to function osal_memcpy
   \   00001A   8E..         MOV     ?V4,R6
   \   00001C   8F..         MOV     ?V5,R7
   \   00001E   75..00       MOV     ?V6,#0x0
   \   000021   78..         MOV     R0,#?V4
   \   000023   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000026   AC..         MOV     R4,?V1
   \   000028   7D00         MOV     R5,#0x0
   \   00002A   7403         MOV     A,#0x3
   \   00002C   12....       LCALL   ?XSTACK_DISP101_8
   \   00002F   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000032   7403         MOV     A,#0x3
   \   000034   12....       LCALL   ?DEALLOC_XSTACK8
    408            buf[tmpLen] = ' ';
   \   000037   A8..         MOV     R0,?V1
   \   000039   12....       LCALL   ?Subroutine2 & 0xFFFF
    409            err = (uint32)(value);
    410            _ltoa( err, &buf[tmpLen+1], format );
   \                     ??CrossCallReturnLabel_0:
   \   00003C                ; Setup parameters for call to function _ltoa
   \   00003C   A3           INC     DPTR
   \   00003D   8582..       MOV     ?V4,DPL
   \   000040   8583..       MOV     ?V5,DPH
   \   000043   78..         MOV     R0,#?V4
   \   000045   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000048   A9..         MOV     R1,?V0
   \   00004A   AA..         MOV     R2,?V2
   \   00004C   AB..         MOV     R3,?V3
   \   00004E   E4           CLR     A
   \   00004F   FC           MOV     R4,A
   \   000050   FD           MOV     R5,A
   \   000051   12....       LCALL   `??_ltoa::?relay`    ; Banked call to: _ltoa
   \   000054   7402         MOV     A,#0x2
   \   000056   12....       LCALL   ?DEALLOC_XSTACK8
    411            HalLcdWriteString( (char*)buf, line );
   \   000059                ; Setup parameters for call to function HalLcdWriteString
   \   000059   7428         MOV     A,#0x28
   \   00005B   12....       LCALL   ?XSTACK_DISP0_8
   \   00005E   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000061   12....       LCALL   `??HalLcdWriteString::?relay`; Banked call to: HalLcdWriteString
    412            
    413           /* 
    414          #if (HAL_LCD == TRUE)
    415            uint8 tmpLen;
    416            uint8 buf[HAL_LCD_MAX_BUFF];
    417            uint32 err;
    418          
    419            tmpLen = (uint8)osal_strlen( (char*)title );
    420            osal_memcpy( buf, title, tmpLen );
    421            buf[tmpLen] = ' ';
    422            err = (uint32)(value);
    423            _ltoa( err, &buf[tmpLen+1], format );
    424            HalLcdWriteString( (char*)buf, line );		
    425          #endif
    426          */
    427          }
   \   000064   7419         MOV     A,#0x19
   \   000066                REQUIRE ?Subroutine1
   \   000066                ; // Fall through to label ?Subroutine1

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F07         MOV     R7,#0x7
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000003   7420         MOV     A,#0x20
   \   000005   F0           MOVX    @DPTR,A
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E582         MOV     A,DPL
   \   000008   28           ADD     A,R0
   \   000009   F582         MOV     DPL,A
   \   00000B   E4           CLR     A
   \   00000C   3583         ADDC    A,DPH
   \   00000E   F583         MOV     DPH,A
   \   000010   22           RET
    428          
    429          /**************************************************************************************************
    430           * @fn      HalLcdWriteStringValue
    431           *
    432           * @brief   Write a string followed by a value to the LCD
    433           *
    434           * @param   title   - Title that will be displayed before the value
    435           *          value1  - value #1
    436           *          format1 - redix of value #1
    437           *          value2  - value #2
    438           *          format2 - redix of value #2
    439           *          line    - line number
    440           *
    441           * @return  None
    442           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    443          void HalLcdWriteStringValueValue( char *title, uint16 value1, uint8 format1,
   \                     HalLcdWriteStringValueValue:
    444                                            uint16 value2, uint8 format2, uint8 line )
    445          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000   74ED         MOV     A,#-0x13
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 19
   \   000005                ; Auto size: 25
   \   000005   74E7         MOV     A,#-0x19
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V4,R4
   \   000010   8D..         MOV     ?V5,R5
   \   000012   89..         MOV     ?V0,R1
    446          
    447          #if (HAL_LCD == TRUE)
    448          
    449            uint8 tmpLen;
    450            uint8 buf[HAL_LCD_MAX_BUFF];
    451            uint32 err;
    452          
    453            tmpLen = (uint8)osal_strlen( (char*)title );
   \   000014                ; Setup parameters for call to function osal_strlen
   \   000014   12....       LCALL   `??osal_strlen::?relay`; Banked call to: osal_strlen
   \   000017   EA           MOV     A,R2
   \   000018   F5..         MOV     ?V2,A
    454            if ( tmpLen )
   \   00001A   6024         JZ      ??HalLcdWriteStringValueValue_0
    455            {
    456              osal_memcpy( buf, title, tmpLen );
   \   00001C                ; Setup parameters for call to function osal_memcpy
   \   00001C   8E..         MOV     ?V8,R6
   \   00001E   8F..         MOV     ?V9,R7
   \   000020   75..00       MOV     ?V10,#0x0
   \   000023   78..         MOV     R0,#?V8
   \   000025   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000028   AC..         MOV     R4,?V2
   \   00002A   7D00         MOV     R5,#0x0
   \   00002C   7403         MOV     A,#0x3
   \   00002E   12....       LCALL   ?XSTACK_DISP101_8
   \   000031   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000034   7403         MOV     A,#0x3
   \   000036   12....       LCALL   ?DEALLOC_XSTACK8
    457              buf[tmpLen++] = ' ';
   \   000039   A8..         MOV     R0,?V2
   \   00003B   12....       LCALL   ?Subroutine2 & 0xFFFF
    458            }
   \                     ??CrossCallReturnLabel_1:
   \   00003E   05..         INC     ?V2
    459          
    460            err = (uint32)(value1);
    461            _ltoa( err, &buf[tmpLen], format1 );
   \                     ??HalLcdWriteStringValueValue_0:
   \   000040                ; Setup parameters for call to function _ltoa
   \   000040   A8..         MOV     R0,?V2
   \   000042   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000045   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000048   A9..         MOV     R1,?V0
   \   00004A   AA..         MOV     R2,?V4
   \   00004C   AB..         MOV     R3,?V5
   \   00004E   E4           CLR     A
   \   00004F   FC           MOV     R4,A
   \   000050   FD           MOV     R5,A
   \   000051   12....       LCALL   `??_ltoa::?relay`    ; Banked call to: _ltoa
   \   000054   7402         MOV     A,#0x2
   \   000056   12....       LCALL   ?DEALLOC_XSTACK8
    462            tmpLen = (uint8)osal_strlen( (char*)buf );
   \   000059                ; Setup parameters for call to function osal_strlen
   \   000059   AA..         MOV     R2,?XSP + 0
   \   00005B   AB..         MOV     R3,?XSP + 1
   \   00005D   12....       LCALL   `??osal_strlen::?relay`; Banked call to: osal_strlen
   \   000060   EA           MOV     A,R2
   \   000061   F5..         MOV     ?V2,A
    463          
    464            buf[tmpLen++] = ',';
   \   000063   F8           MOV     R0,A
   \   000064   85..82       MOV     DPL,?XSP + 0
   \   000067   85..83       MOV     DPH,?XSP + 1
   \   00006A   E582         MOV     A,DPL
   \   00006C   2A           ADD     A,R2
   \   00006D   F582         MOV     DPL,A
   \   00006F   E4           CLR     A
   \   000070   3583         ADDC    A,DPH
   \   000072   F583         MOV     DPH,A
   \   000074   742C         MOV     A,#0x2c
   \   000076   F0           MOVX    @DPTR,A
    465            buf[tmpLen++] = ' ';
   \   000077   08           INC     R0
   \   000078   12....       LCALL   ?Subroutine2 & 0xFFFF
    466            err = (uint32)(value2);
    467            _ltoa( err, &buf[tmpLen], format2 );
   \                     ??CrossCallReturnLabel_2:
   \   00007B                ; Setup parameters for call to function _ltoa
   \   00007B   08           INC     R0
   \   00007C   12....       LCALL   ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   00007F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000082   7430         MOV     A,#0x30
   \   000084   12....       LCALL   ?XSTACK_DISP0_8
   \   000087   E0           MOVX    A,@DPTR
   \   000088   F9           MOV     R1,A
   \   000089   742E         MOV     A,#0x2e
   \   00008B   12....       LCALL   ?XSTACK_DISP0_8
   \   00008E   E0           MOVX    A,@DPTR
   \   00008F   F5..         MOV     ?V2,A
   \   000091   A3           INC     DPTR
   \   000092   E0           MOVX    A,@DPTR
   \   000093   AA..         MOV     R2,?V2
   \   000095   FB           MOV     R3,A
   \   000096   E4           CLR     A
   \   000097   FC           MOV     R4,A
   \   000098   FD           MOV     R5,A
   \   000099   12....       LCALL   `??_ltoa::?relay`    ; Banked call to: _ltoa
   \   00009C   7402         MOV     A,#0x2
   \   00009E   12....       LCALL   ?DEALLOC_XSTACK8
    468          
    469            HalLcdWriteString( (char *)buf, line );		
   \   0000A1                ; Setup parameters for call to function HalLcdWriteString
   \   0000A1   742F         MOV     A,#0x2f
   \   0000A3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A6   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   0000A9   12....       LCALL   `??HalLcdWriteString::?relay`; Banked call to: HalLcdWriteString
    470          
    471          #endif
    472          }
   \   0000AC   7419         MOV     A,#0x19
   \   0000AE   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B1   7F0B         MOV     R7,#0xb
   \   0000B3   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E582         MOV     A,DPL
   \   000008   28           ADD     A,R0
   \   000009   F5..         MOV     ?V2,A
   \   00000B   E4           CLR     A
   \   00000C   3583         ADDC    A,DPH
   \   00000E   F5..         MOV     ?V3,A
   \   000010   78..         MOV     R0,#?V2
   \   000012   22           RET
    473          
    474          /**************************************************************************************************
    475           * @fn      HalLcdDisplayPercentBar
    476           *
    477           * @brief   Display percentage bar on the LCD
    478           *
    479           * @param   title   -
    480           *          value   -
    481           *
    482           * @return  None
    483           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    484          void HalLcdDisplayPercentBar( char *title, uint8 value )
   \                     HalLcdDisplayPercentBar:
    485          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 17
   \   000005   74EF         MOV     A,#-0x11
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
    486          #if (HAL_LCD == TRUE)
    487          
    488            uint8 percent;
    489            uint8 leftOver;
    490            uint8 buf[17];
    491            uint32 err;
    492            uint8 x;
    493          
    494            /* Write the title: */
    495            HalLcdWriteString( title, HAL_LCD_LINE_1 );
   \   00000C                ; Setup parameters for call to function HalLcdWriteString
   \   00000C   7901         MOV     R1,#0x1
   \   00000E   12....       LCALL   `??HalLcdWriteString::?relay`; Banked call to: HalLcdWriteString
    496          
    497            if ( value > 100 )
   \   000011   EE           MOV     A,R6
   \   000012   C3           CLR     C
   \   000013   9465         SUBB    A,#0x65
   \   000015   4002         JC      ??HalLcdDisplayPercentBar_0
    498              value = 100;
   \   000017   7E64         MOV     R6,#0x64
    499          
    500            /* convert to blocks */
    501            percent = (uint8)(value / 10);
   \                     ??HalLcdDisplayPercentBar_0:
   \   000019   75F00A       MOV     B,#0xa
   \   00001C   EE           MOV     A,R6
   \   00001D   84           DIV     AB
   \   00001E   F5..         MOV     ?V0,A
    502            leftOver = (uint8)(value % 10);
   \   000020   EE           MOV     A,R6
   \   000021   75F00A       MOV     B,#0xa
   \   000024   84           DIV     AB
   \   000025   E5F0         MOV     A,B
   \   000027   F5..         MOV     ?V1,A
    503          
    504            /* Make window */
    505            osal_memcpy( buf, "[          ]  ", 15 );
   \   000029                ; Setup parameters for call to function osal_memcpy
   \   000029   75....       MOV     ?V4,#`?<Constant "[          ]  ">` & 0xff
   \   00002C   75....       MOV     ?V5,#(`?<Constant "[          ]  ">` >> 8) & 0xff
   \   00002F   75..00       MOV     ?V6,#0x0
   \   000032   78..         MOV     R0,#?V4
   \   000034   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000037   7C0F         MOV     R4,#0xf
   \   000039   7D00         MOV     R5,#0x0
   \   00003B   7403         MOV     A,#0x3
   \   00003D   12....       LCALL   ?XSTACK_DISP101_8
   \   000040   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000043   7403         MOV     A,#0x3
   \   000045   12....       LCALL   ?DEALLOC_XSTACK8
    506          
    507            for ( x = 0; x < percent; x ++ )
   \   000048   7F00         MOV     R7,#0x0
   \   00004A   E5..         MOV     A,?V0
   \   00004C   601A         JZ      ??HalLcdDisplayPercentBar_1
    508            {
    509              buf[1+x] = '>';
   \   00004E   F8           MOV     R0,A
   \   00004F   7900         MOV     R1,#0x0
   \   000051   7A3E         MOV     R2,#0x3e
   \   000053   7401         MOV     A,#0x1
   \   000055   12....       LCALL   ?XSTACK_DISP0_8
   \                     ??HalLcdDisplayPercentBar_2:
   \   000058   EA           MOV     A,R2
   \   000059   F0           MOVX    @DPTR,A
   \   00005A   A3           INC     DPTR
   \   00005B   E8           MOV     A,R0
   \   00005C   24FF         ADD     A,#-0x1
   \   00005E   18           DEC     R0
   \   00005F   E9           MOV     A,R1
   \   000060   34FF         ADDC    A,#-0x1
   \   000062   F9           MOV     R1,A
   \   000063   48           ORL     A,R0
   \   000064   70F2         JNZ     ??HalLcdDisplayPercentBar_2
    510            }
   \   000066   AF..         MOV     R7,?V0
    511          
    512            if ( leftOver >= 5 )
   \                     ??HalLcdDisplayPercentBar_1:
   \   000068   E5..         MOV     A,?V1
   \   00006A   C3           CLR     C
   \   00006B   9405         SUBB    A,#0x5
   \   00006D   4009         JC      ??HalLcdDisplayPercentBar_3
    513              buf[1+x] = '+';
   \   00006F   EF           MOV     A,R7
   \   000070   F8           MOV     R0,A
   \   000071   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000074   A3           INC     DPTR
   \   000075   742B         MOV     A,#0x2b
   \   000077   F0           MOVX    @DPTR,A
    514          
    515            err = (uint32)value;
    516            _ltoa( err, (uint8*)&buf[13], 10 );
   \                     ??HalLcdDisplayPercentBar_3:
   \   000078                ; Setup parameters for call to function _ltoa
   \   000078   740D         MOV     A,#0xd
   \   00007A   12....       LCALL   ?XSTACK_DISP0_8
   \   00007D   8582..       MOV     ?V0,DPL
   \   000080   8583..       MOV     ?V1,DPH
   \   000083   78..         MOV     R0,#?V0
   \   000085   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000088   790A         MOV     R1,#0xa
   \   00008A   EE           MOV     A,R6
   \   00008B   FA           MOV     R2,A
   \   00008C   E4           CLR     A
   \   00008D   FB           MOV     R3,A
   \   00008E   FC           MOV     R4,A
   \   00008F   FD           MOV     R5,A
   \   000090   12....       LCALL   `??_ltoa::?relay`    ; Banked call to: _ltoa
   \   000093   7402         MOV     A,#0x2
   \   000095   12....       LCALL   ?DEALLOC_XSTACK8
    517          
    518            HalLcdWriteString( (char*)buf, HAL_LCD_LINE_2 );
   \   000098                ; Setup parameters for call to function HalLcdWriteString
   \   000098   7902         MOV     R1,#0x2
   \   00009A   AA..         MOV     R2,?XSP + 0
   \   00009C   AB..         MOV     R3,?XSP + 1
   \   00009E   12....       LCALL   `??HalLcdWriteString::?relay`; Banked call to: HalLcdWriteString
    519          
    520          #endif
    521          
    522          }
   \   0000A1   7411         MOV     A,#0x11
   \   0000A3   02....       LJMP    ?Subroutine1 & 0xFFFF
    523          
    524          #if (HAL_LCD == TRUE)
    525          /**************************************************************************************************
    526           *                                    HARDWARE LCD
    527           **************************************************************************************************/
    528          
    529          /**************************************************************************************************
    530           * @fn      halLcd_ConfigIO
    531           *
    532           * @brief   Configure IO lines needed for LCD control.
    533           *
    534           * @param   None
    535           *
    536           * @return  None
    537           **************************************************************************************************/
    538          static void halLcd_ConfigIO(void)
                             ^
Warning[Pe177]: function "halLcd_ConfigIO" was declared but never referenced
    539          {/*
    540            //GPIO configuration
    541            HAL_CONFIG_IO_OUTPUT(HAL_LCD_MODE_PORT,  HAL_LCD_MODE_PIN,  1);
    542            HAL_CONFIG_IO_OUTPUT(HAL_LCD_RESET_PORT, HAL_LCD_RESET_PIN, 1);
    543            HAL_CONFIG_IO_OUTPUT(HAL_LCD_CS_PORT,    HAL_LCD_CS_PIN,    1);
    544          */
    545          }
    546          
    547          /**************************************************************************************************
    548           * @fn      halLcd_ConfigSPI
    549           *
    550           * @brief   Configure SPI lines needed for talking to LCD.
    551           *
    552           * @param   None
    553           *
    554           * @return  None
    555           **************************************************************************************************/
    556          static void halLcd_ConfigSPI(void)
                             ^
Warning[Pe177]: function "halLcd_ConfigSPI" was declared but never referenced
    557          {
    558            // UART/SPI Peripheral configuration
    559          /*
    560             uint8 baud_exponent;
    561             uint8 baud_mantissa;
    562          
    563            // Set SPI on UART 1 alternative 2 
    564            PERCFG |= 0x02;
    565          
    566            // Configure clk, master out and master in lines
    567            HAL_CONFIG_IO_PERIPHERAL(HAL_LCD_CLK_PORT,  HAL_LCD_CLK_PIN);
    568            HAL_CONFIG_IO_PERIPHERAL(HAL_LCD_MOSI_PORT, HAL_LCD_MOSI_PIN);
    569            HAL_CONFIG_IO_PERIPHERAL(HAL_LCD_MISO_PORT, HAL_LCD_MISO_PIN);
    570          
    571          
    572            // Set SPI speed to 1 MHz (the values assume system clk of 32MHz)
    573            // Confirm on board that this results in 1MHz spi clk.
    574             
    575            baud_exponent = 15;
    576            baud_mantissa =  0;
    577          
    578            // Configure SPI 
    579            U1UCR  = 0x80;      // Flush and goto IDLE state. 8-N-1. 
    580            U1CSR  = 0x00;      // SPI mode, master.
    581            U1GCR  = HAL_SPI_TRANSFER_MSB_FIRST | HAL_SPI_CLOCK_PHA_0 | HAL_SPI_CLOCK_POL_LO | baud_exponent;
    582            U1BAUD = baud_mantissa;
    583            */
    584          }
    585          
    586          /**************************************************************************************************
    587           * @fn      HalLcd_HW_Init
    588           *
    589           * @brief   Initilize HW LCD Driver.
    590           *
    591           * @param   None
    592           *
    593           * @return  None
    594           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    595          void HalLcd_HW_Init(void)
   \                     HalLcd_HW_Init:
    596          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    597            
    598             // CLKCONCMD =0x00;                                                            //Podesavanje clocka na 32MHz
    599              
    600            
    601              //PERCFG = 0x00;                                                              //Podesavanje primarnih funkcija modula 
    602              P0SEL = 0x0C;                                                               //Podesavanje osnovne ili periferne funkcije odredjenog pina(0-osnovna ; 1-periferna)
   \   000000   75F30C       MOV     0xf3,#0xc
    603              
    604            
    605              U0CSR = 0xC0;                                                               //Prvi bit 1 je UART mode
   \   000003   7586C0       MOV     0x86,#-0x40
    606              U0GCR = 0x08;                                                               //Poslednjih 5 bita odredjuje baud rate exponent vrijednost
   \   000006   75C508       MOV     0xc5,#0x8
    607           
    608              
    609              U0BAUD = 0x3A;                                                              //Postavja baud rate na 9600
   \   000009   75C23A       MOV     0xc2,#0x3a
    610              
    611            
    612            
    613            /* Initialize LCD IO lines 
    614            halLcd_ConfigIO();
    615          
    616            // Initialize SPI 
    617            halLcd_ConfigSPI();
    618          
    619            // Perform reset 
    620            LCD_ACTIVATE_RESET();
    621            HalLcd_HW_WaitUs(15000); // 15 ms
    622            LCD_RELEASE_RESET();
    623            HalLcd_HW_WaitUs(15); // 15 us
    624          
    625            // Perform the initialization sequence 
    626            FUNCTION_SET(CGRAM | COM_FORWARD | THREE_LINE);
    627          
    628            // Set contrast 
    629            HalLcd_HW_SetContrast(15);
    630          
    631            // Set power 
    632            SET_POWER_SAVE_MODE(OSC_OFF | POWER_SAVE_ON);
    633            SET_POWER_CTRL(VOLTAGE_DIVIDER_ON | CONVERTER_AND_REG_ON);
    634            SET_BIAS_CTRL(BIAS_1_5);
    635            HalLcd_HW_WaitUs(21000);// 21 ms
    636          
    637            // Clear the display 
    638            HalLcd_HW_Clear();
    639            HalLcd_HW_ClearAllSpecChars();
    640            SET_DISPLAY_CTRL(DISPLAY_CTRL_ON | DISPLAY_CTRL_BLINK_OFF | DISPLAY_CTRL_CURSOR_OFF);
    641          */
    642          
    643          }
   \   00000C   02....       LJMP    ?BRET
   \   00000F                REQUIRE P0SEL
   \   00000F                REQUIRE U0CSR
   \   00000F                REQUIRE U0GCR
   \   00000F                REQUIRE U0BAUD
    644          
    645          /**************************************************************************************************
    646           * @fn      HalLcd_HW_Control
    647           *
    648           * @brief   Write 1 command to the LCD
    649           *
    650           * @param   uint8 cmd - command to be written to the LCD
    651           *
    652           * @return  None
    653           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    654          void HalLcd_HW_Control(uint8 cmd)
   \                     HalLcd_HW_Control:
    655          {/*
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    656            LCD_SPI_BEGIN();
    657            LCD_DO_CONTROL();
    658            LCD_SPI_TX(cmd);
    659            LCD_SPI_WAIT_RXRDY();
    660            LCD_SPI_END();
    661          */
    662          }
   \   000000   02....       LJMP    ?BRET
    663          
    664          /**************************************************************************************************
    665           * @fn      HalLcd_HW_Write
    666           *
    667           * @brief   Write 1 byte to the LCD
    668           *
    669           * @param   uint8 data - data to be written to the LCD
    670           *
    671           * @return  None
    672           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    673          void HalLcd_HW_Write(uint8 data)
   \                     HalLcd_HW_Write:
    674          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    675            U0DBUF = data;
   \   000000   89C1         MOV     0xc1,R1
    676              
    677              while((U0CSR & 0x01) == 0x01)
   \                     ??HalLcd_HW_Write_0:
   \   000002   E586         MOV     A,0x86
   \   000004   A2E0         MOV     C,0xE0 /* A   */.0
   \   000006   40FA         JC      ??HalLcd_HW_Write_0
    678              {
    679              }
    680            
    681            /*
    682            LCD_SPI_BEGIN();
    683            LCD_DO_WRITE();
    684            LCD_SPI_TX(data);
    685            LCD_SPI_WAIT_RXRDY();
    686            LCD_SPI_END();
    687          */
    688          }
   \   000008   02....       LJMP    ?BRET
   \   00000B                REQUIRE U0DBUF
   \   00000B                REQUIRE U0CSR
    689          
    690          /**************************************************************************************************
    691           * @fn          HalLcd_HW_SetContrast
    692           *
    693           * @brief       Set display contrast
    694           *
    695           * @param       uint8 value - contrast value
    696           *
    697           * @return      none
    698           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    699          void HalLcd_HW_SetContrast(uint8 value)
   \                     HalLcd_HW_SetContrast:
    700          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    701            /*
    702            SET_ICONRAM_ADDR(CONTRAST_CTRL_REGISTER);
    703            HalLcd_HW_Write(value);
    704          */
    705          }
   \   000000   02....       LJMP    ?BRET
    706          
    707          /**************************************************************************************************
    708           * @fn      HalLcd_HW_Clear
    709           *
    710           * @brief   Clear the HW LCD
    711           *
    712           * @param   None
    713           *
    714           * @return  None
    715           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    716          void HalLcd_HW_Clear(void)
   \                     HalLcd_HW_Clear:
    717          {/*
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    718            uint8 n;
    719          
    720            SET_DDRAM_ADDR(0x00);
    721            for (n = 0; n < (LCD_MAX_LINE_COUNT * HAL_LCD_MAX_CHARS); n++)
    722            {
    723              HalLcd_HW_Write(' ');
    724            }
    725            */
    726          }
   \   000000   02....       LJMP    ?BRET
    727          
    728          /**************************************************************************************************
    729           * @fn      HalLcd_HW_ClearAllSpecChars
    730           *
    731           * @brief   Clear all special chars
    732           *
    733           * @param   None
    734           *
    735           * @return  None
    736           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    737          void HalLcd_HW_ClearAllSpecChars(void)
   \                     HalLcd_HW_ClearAllSpecChars:
    738          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    739            /*
    740            uint8 n = 0;
    741          
    742            SET_GCRAM_CHAR(0);
    743            for (n = 0; n < (8 * 8); n++)
    744            {
    745              HalLcd_HW_Write(0x00);
    746            }
    747            */
    748          }
   \   000000   02....       LJMP    ?BRET
    749          
    750          /**************************************************************************************************
    751           * @fn      HalLcd_HW_WriteChar
    752           *
    753           * @brief   Write one char to the display
    754           *
    755           * @param   uint8 line - line number that the char will be displayed
    756           *          uint8 col - colum where the char will be displayed
    757           *
    758           * @return  None
    759           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    760          void HalLcd_HW_WriteChar(uint8 line, uint8 col, char text)
   \                     HalLcd_HW_WriteChar:
    761          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EB           MOV     A,R3
    762            HalLcd_HW_Write(text);
   \   000006                ; Setup parameters for call to function HalLcd_HW_Write
   \   000006   F9           MOV     R1,A
   \   000007   02....       LJMP    ?Subroutine0 & 0xFFFF
    763            
    764            /*
    765            if (col < HAL_LCD_MAX_CHARS)
    766            {
    767              SET_DDRAM_ADDR((line - 1) * HAL_LCD_MAX_CHARS + col);
    768              HalLcd_HW_Write(text);
    769            }
    770            else
    771            {
    772              return;
    773            }
    774            */
    775          }
    776          
    777          /**************************************************************************************************
    778           * @fn          halLcdWriteLine
    779           *
    780           * @brief       Write one line on display
    781           *
    782           * @param       uint8 line - display line
    783           *              char *pText - text buffer to write
    784           *
    785           * @return      none
    786           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    787          void HalLcd_HW_WriteLine(uint8 line, const char *pText)
   \                     HalLcd_HW_WriteLine:
    788          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    789            uint8 count;
    790            uint8 totalLength = (uint8)osal_strlen( (char *)pText );
   \   000009                ; Setup parameters for call to function osal_strlen
   \   000009   12....       LCALL   `??osal_strlen::?relay`; Banked call to: osal_strlen
   \   00000C   EA           MOV     A,R2
   \   00000D   F5..         MOV     ?V1,A
    791          
    792            /* Write the content first */
    793            for (count=0; count<totalLength; count++)
   \   00000F   75..00       MOV     ?V0,#0x0
   \   000012   8014         SJMP    ??HalLcd_HW_WriteLine_0
    794            {
    795              HalLcd_HW_WriteChar(line, count, (*(pText++)));
   \                     ??HalLcd_HW_WriteLine_1:
   \   000014                ; Setup parameters for call to function HalLcd_HW_Write
   \   000014   8E82         MOV     DPL,R6
   \   000016   8F83         MOV     DPH,R7
   \   000018   E0           MOVX    A,@DPTR
   \   000019   F9           MOV     R1,A
   \   00001A   12....       LCALL   `??HalLcd_HW_Write::?relay`; Banked call to: HalLcd_HW_Write
   \   00001D   8E82         MOV     DPL,R6
   \   00001F   8F83         MOV     DPH,R7
   \   000021   A3           INC     DPTR
   \   000022   AE82         MOV     R6,DPL
   \   000024   AF83         MOV     R7,DPH
    796            }
   \   000026   05..         INC     ?V0
   \                     ??HalLcd_HW_WriteLine_0:
   \   000028   E5..         MOV     A,?V0
   \   00002A   C3           CLR     C
   \   00002B   95..         SUBB    A,?V1
   \   00002D   40E5         JC      ??HalLcd_HW_WriteLine_1
    797          
    798            /* Write blank spaces to rest of the line */
    799            for(count=totalLength; count<HAL_LCD_MAX_CHARS;count++)
   \   00002F   85....       MOV     ?V0,?V1
   \   000032   8007         SJMP    ??HalLcd_HW_WriteLine_2
    800            {
    801              HalLcd_HW_WriteChar(line, count, ' ');
   \                     ??HalLcd_HW_WriteLine_3:
   \   000034                ; Setup parameters for call to function HalLcd_HW_Write
   \   000034   7920         MOV     R1,#0x20
   \   000036   12....       LCALL   `??HalLcd_HW_Write::?relay`; Banked call to: HalLcd_HW_Write
    802            }
   \   000039   05..         INC     ?V0
   \                     ??HalLcd_HW_WriteLine_2:
   \   00003B   E5..         MOV     A,?V0
   \   00003D   C3           CLR     C
   \   00003E   9410         SUBB    A,#0x10
   \   000040   40F2         JC      ??HalLcd_HW_WriteLine_3
    803          }
   \   000042   7F02         MOV     R7,#0x2
   \   000044   02....       LJMP    ?BANKED_LEAVE_XDATA
    804          
    805          /**************************************************************************************************
    806           * @fn      HalLcd_HW_WaitUs
    807           *
    808           * @brief   wait for x us. @ 32MHz MCU clock it takes 32 "nop"s for 1 us delay.
    809           *
    810           * @param   x us. range[0-65536]
    811           *
    812           * @return  None
    813           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    814          void HalLcd_HW_WaitUs(uint16 microSecs)
   \                     HalLcd_HW_WaitUs:
    815          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   8020         SJMP    ??HalLcd_HW_WaitUs_0
    816            while(microSecs--)
    817            {
    818              /* 32 NOPs == 1 usecs */
    819              asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
   \                     ??HalLcd_HW_WaitUs_1:
   \   000002   00           nop
   \   000003   00           nop
   \   000004   00           nop
   \   000005   00           nop
   \   000006   00           nop
    820              asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
   \   000007   00           nop
   \   000008   00           nop
   \   000009   00           nop
   \   00000A   00           nop
   \   00000B   00           nop
    821              asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
   \   00000C   00           nop
   \   00000D   00           nop
   \   00000E   00           nop
   \   00000F   00           nop
   \   000010   00           nop
    822              asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
   \   000011   00           nop
   \   000012   00           nop
   \   000013   00           nop
   \   000014   00           nop
   \   000015   00           nop
    823              asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
   \   000016   00           nop
   \   000017   00           nop
   \   000018   00           nop
   \   000019   00           nop
   \   00001A   00           nop
    824              asm("nop"); asm("nop"); asm("nop"); asm("nop"); asm("nop");
   \   00001B   00           nop
   \   00001C   00           nop
   \   00001D   00           nop
   \   00001E   00           nop
   \   00001F   00           nop
    825              asm("nop"); asm("nop");
   \   000020   00           nop
   \   000021   00           nop
    826            }
   \                     ??HalLcd_HW_WaitUs_0:
   \   000022   EA           MOV     A,R2
   \   000023   F8           MOV     R0,A
   \   000024   EB           MOV     A,R3
   \   000025   F9           MOV     R1,A
   \   000026   E8           MOV     A,R0
   \   000027   24FF         ADD     A,#-0x1
   \   000029   1A           DEC     R2
   \   00002A   E9           MOV     A,R1
   \   00002B   34FF         ADDC    A,#-0x1
   \   00002D   FB           MOV     R3,A
   \   00002E   E8           MOV     A,R0
   \   00002F   49           ORL     A,R1
   \   000030   70D0         JNZ     ??HalLcd_HW_WaitUs_1
    827          }
   \   000032   02....       LJMP    ?BRET

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalLcdInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalLcdWriteString::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdWriteString

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalLcdWriteValue::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdWriteValue

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalLcdWriteScreen::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdWriteScreen

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalLcdWriteStringValue::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdWriteStringValue

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalLcdWriteStringValueValue::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdWriteStringValueValue

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalLcdDisplayPercentBar::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcdDisplayPercentBar

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalLcd_HW_Init::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcd_HW_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalLcd_HW_Control::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcd_HW_Control

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalLcd_HW_Write::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcd_HW_Write

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalLcd_HW_SetContrast::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcd_HW_SetContrast

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalLcd_HW_Clear::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcd_HW_Clear

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalLcd_HW_ClearAllSpecChars::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcd_HW_ClearAllSpecChars

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalLcd_HW_WriteChar::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcd_HW_WriteChar

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalLcd_HW_WriteLine::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcd_HW_WriteLine

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??HalLcd_HW_WaitUs::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalLcd_HW_WaitUs

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "[          ]  ">`:
   \   000000   5B202020     DB "[          ]  "
   \            20202020
   \            2020205D
   \            202000  
    828          #endif
    829          
    830          
    831          /**************************************************************************************************
    832          **************************************************************************************************/
    833          
    834          
    835          

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     35   HalLcdDisplayPercentBar
        0     32   -> HalLcdWriteString
        0     34   -> _ltoa
        0     35   -> osal_memcpy
      2      0   HalLcdInit
        2      0   -> HalLcd_HW_Init
      0      0   HalLcdWriteScreen
      0     53   HalLcdWriteString
        0      9   -> HalLcd_HW_Write
      0     44   HalLcdWriteStringValue
        0     40   -> HalLcdWriteString
        0     42   -> _ltoa
        0     43   -> osal_memcpy
        0     40   -> osal_strlen
      0     51   HalLcdWriteStringValueValue
        0     44   -> HalLcdWriteString
        0     46   -> _ltoa
        0     47   -> osal_memcpy
        0     44   -> osal_strlen
      0     42   HalLcdWriteValue
        0     39   -> HalLcdWriteString
        0     41   -> _ltoa
      0      0   HalLcd_HW_Clear
      0      0   HalLcd_HW_ClearAllSpecChars
      0      0   HalLcd_HW_Control
      0      0   HalLcd_HW_Init
      0      0   HalLcd_HW_SetContrast
      0      0   HalLcd_HW_WaitUs
      0     10   HalLcd_HW_Write
      0      9   HalLcd_HW_WriteChar
        0      9   -> HalLcd_HW_Write
      0     10   HalLcd_HW_WriteLine
        0     10   -> HalLcd_HW_Write
        0     10   -> osal_strlen


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      15  ?<Constant "[          ]  ">
       8  ?Subroutine0
       8  ?Subroutine1
       7  ?Subroutine2
      19  ?Subroutine3
       7  ?Subroutine4
      17  ?Subroutine5
     166  HalLcdDisplayPercentBar
       6  HalLcdDisplayPercentBar::?relay
      14  HalLcdInit
       6  HalLcdInit::?relay
       3  HalLcdWriteScreen
       6  HalLcdWriteScreen::?relay
      35  HalLcdWriteString
       6  HalLcdWriteString::?relay
     102  HalLcdWriteStringValue
       6  HalLcdWriteStringValue::?relay
     182  HalLcdWriteStringValueValue
       6  HalLcdWriteStringValueValue::?relay
      56  HalLcdWriteValue
       6  HalLcdWriteValue::?relay
       3  HalLcd_HW_Clear
       6  HalLcd_HW_Clear::?relay
       3  HalLcd_HW_ClearAllSpecChars
       6  HalLcd_HW_ClearAllSpecChars::?relay
       3  HalLcd_HW_Control
       6  HalLcd_HW_Control::?relay
      15  HalLcd_HW_Init
       6  HalLcd_HW_Init::?relay
       3  HalLcd_HW_SetContrast
       6  HalLcd_HW_SetContrast::?relay
      53  HalLcd_HW_WaitUs
       6  HalLcd_HW_WaitUs::?relay
      11  HalLcd_HW_Write
       6  HalLcd_HW_Write::?relay
      10  HalLcd_HW_WriteChar
       6  HalLcd_HW_WriteChar::?relay
      71  HalLcd_HW_WriteLine
       6  HalLcd_HW_WriteLine::?relay
       1  P0SEL
       1  U0BAUD
       1  U0CSR
       1  U0DBUF
       1  U0GCR

 
 796 bytes in segment BANKED_CODE
  96 bytes in segment BANK_RELAYS
   5 bytes in segment SFR_AN
  15 bytes in segment XDATA_ROM_C
 
  96 bytes of CODE     memory
  15 bytes of CONST    memory
   0 bytes of DATA     memory (+ 5 bytes shared)
 796 bytes of HUGECODE memory

Errors: none
Warnings: 7
