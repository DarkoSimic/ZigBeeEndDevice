###############################################################################
#
# IAR C/C++ Compiler V9.30.3.3983 for 8051                20/Apr/2017  12:17:48
# Copyright 2004-2016 IAR Systems AB.
# Evaluation license - IAR Embedded Workbench for 8051, Evaluation version 9.30
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\ZMain\TI2530DB\ZMain.c
#    Command line       =  
#        -f
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0x0422
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)
#        -DREJOIN_POLL_RATE=440
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\ZMain\TI2530DB\ZMain.c
#        -D NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC
#        -D LCD_SUPPORTED=DEBUG -D xPOWER_SAVING -lC
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\EndDeviceEB\List
#        -lA
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\EndDeviceEB\List
#        --diag_suppress Pe001,Pa010 -o
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\EndDeviceEB\Obj
#        -e --no_code_motion --debug --core=plain --dptr=16,1
#        --data_model=large --code_model=banked
#        --calling_convention=xdata_reentrant --place_constants=data_rom
#        --nr_virtual_regs 16 -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\Source\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\ZMain\TI2530DB\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\hal\include\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\include\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\high_level\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mt\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\osal\include\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\services\saddr\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\services\sdata\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\af\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\nwk\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\sapi\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\sec\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\sys\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\zdo\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\zmac\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\zmac\f8w\
#        -I
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Components\hal\BME280_driver-master\
#        -Ohz --require_prototypes
#    List file          =  
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\EndDeviceEB\List\ZMain.lst
#    Object file        =  
#        C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\Samples\GenericApp\CC2530DB\EndDeviceEB\Obj\ZMain.r51
#
###############################################################################

C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\ZMain\TI2530DB\ZMain.c
      1          /**************************************************************************************************
      2            Filename:       ZMain.c
      3            Revised:        $Date: 2010-09-17 16:25:30 -0700 (Fri, 17 Sep 2010) $
      4            Revision:       $Revision: 23835 $
      5          
      6            Description:    Startup and shutdown code for ZStack
      7            Notes:          This version targets the Chipcon CC2530
      8          
      9          
     10            Copyright 2005-2010 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License").  You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product.  Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED �AS IS� WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com.
     39          **************************************************************************************************/
     40          
     41          /*********************************************************************
     42           * INCLUDES
     43           */
     44          
     45          #ifndef NONWK
     46          #include "AF.h"
     47          #endif
     48          #include "hal_adc.h"

   \                                 In  segment SFR_AN, at 0x8f
   \   unsigned char volatile __sfr P0INP
   \                     P0INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9d
   \   unsigned char volatile __sfr SLEEPSTA
   \                     SLEEPSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9e
   \   unsigned char volatile __sfr CLKCONSTA
   \                     CLKCONSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbe
   \   unsigned char volatile __sfr SLEEPCMD
   \                     SLEEPCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc6
   \   unsigned char volatile __sfr CLKCONCMD
   \                     CLKCONCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfe
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1
     49          #include "hal_flash.h"
     50          #include "hal_lcd.h"
     51          #include "hal_led.h"
     52          #include "hal_drivers.h"
     53          #include "OnBoard.h"
     54          #include "OSAL.h"
     55          #include "OSAL_Nv.h"
     56          #include "ZComDef.h"
     57          #include "ZMAC.h"
     58          #include "ioCC2530.h"
     59          
     60          #include "bme280.h"

  #define	SUCCESS							((u8)0)
         	^
"C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Components\hal\BME280_driver-master\bme280.h",537  Warning[Pe047]: 
          incompatible redefinition of macro "SUCCESS" (declared at line 93 of
          "C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Components\osa
          l\include\comdef.h")
     61          
     62          
     63          typedef uint8   u8;
                                 ^
Warning[Pe301]: typedef name has already been declared (with same type)
     64          typedef int8    s8;
                                 ^
Warning[Pe301]: typedef name has already been declared (with same type)
     65          
     66          /*********************************************************************
     67           * DEFINES
     68           */
     69          
     70             

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     71           struct bme280_t bme280;
   \                     bme280:
   \   000000                DS 51
   \   000033                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     72           struct value Value;
   \                     Value:
   \   000000                DS 12
   \   00000C                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     73           signed char flag;   
   \                     flag:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     74             
     75          
     76          //#define T_MIN 					23
     77          //#define T_MAX						24
     78          
     79          /*********************************************************************
     80           * GLOBAL VARIABLES
     81           */
     82          
     83          
     84          
     85          /*********************************************************************
     86           * LOCAL FUNCTIONS
     87           */
     88          
     89          void tempCheck(struct value *val);
     90          
     91          
     92          /*********************************************************************
     93           * EXTERN FUNCTIONS
     94           */
     95          extern s8 BME280_SPI_bus_read(u8 , u8 , u8 *, u8 );
     96          
     97          extern void Onboard_wait( uint16 timeout );
     98          
     99          extern void uartInit(void);
    100          extern void uartSend(char);
    101          extern void magneticSwitchInit(void);
    102          extern void HalLcdWriteString ( char *, uint8 );
    103          extern void HalLcd_HW_Init(void);
    104          
    105          void WriteHex(char );
    106          
    107          static void zmain_ext_addr( void );
    108          #if defined ZCL_KEY_ESTABLISH
    109          static void zmain_cert_init( void );
    110          #endif
    111          static void zmain_dev_info( void );
    112          static void zmain_vdd_check( void );
    113          
    114          #ifdef LCD_SUPPORTED
    115          static void zmain_lcd_init( void );
    116          #endif
    117          
    118          /*********************************************************************
    119           * @fn      main
    120           * @brief   First function called after startup.
    121           * @return  don't care
    122           */
    123          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    124          void WriteHex(char h)
   \                     WriteHex:
    125          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV     A,#-0x3
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
    126            char str[3] = {0,0};
   \   00000C   90....       MOV     DPTR,#`?<Constant {0, 0, 0}>`
   \   00000F   AC..         MOV     R4,?XSP + 0
   \   000011   AD..         MOV     R5,?XSP + 1
   \   000013   7403         MOV     A,#0x3
   \   000015   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    127            
    128          
    129              str[1] = h % 16 + '0';
   \   000018   740F         MOV     A,#0xf
   \   00001A   5E           ANL     A,R6
   \   00001B   2430         ADD     A,#0x30
   \   00001D   C0E0         PUSH    A
   \   00001F   7401         MOV     A,#0x1
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   D0E0         POP     A
   \   000026   F0           MOVX    @DPTR,A
    130              h/=16;
    131              str[0] = h % 16 + '0';
   \   000027   EE           MOV     A,R6
   \   000028   C4           SWAP    A
   \   000029   540F         ANL     A,#0xf
   \   00002B   2430         ADD     A,#0x30
   \   00002D   85..82       MOV     DPL,?XSP + 0
   \   000030   85..83       MOV     DPH,?XSP + 1
   \   000033   F0           MOVX    @DPTR,A
    132                  
    133              str[2] = '\0';
   \   000034   7402         MOV     A,#0x2
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   E4           CLR     A
   \   00003A   F0           MOVX    @DPTR,A
    134              
    135              HalLcdWriteString(str,0);
   \   00003B                ; Setup parameters for call to function HalLcdWriteString
   \   00003B   F9           MOV     R1,A
   \   00003C   AA..         MOV     R2,?XSP + 0
   \   00003E   AB..         MOV     R3,?XSP + 1
   \   000040   12....       LCALL   `??HalLcdWriteString::?relay`; Banked call to: HalLcdWriteString
    136              
    137          }
   \   000043   7403         MOV     A,#0x3
   \   000045   12....       LCALL   ?DEALLOC_XSTACK8
   \   000048   7F01         MOV     R7,#0x1
   \   00004A   02....       LJMP    ?BANKED_LEAVE_XDATA
    138          static struct bme280_t *p_bme280; 

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    139          int main( void )
   \                     main:
    140          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                ; Auto size: 17
   \   000000   74EF         MOV     A,#-0x11
   \   000002   12....       LCALL   ?ALLOC_XSTACK8
    141          
    142            uint16 i;
    143            uint8 chipID;
                         ^
Warning[Pe177]: variable "chipID" was declared but never referenced
    144            
    145          
    146            // Turn off interrupts
    147            osal_int_disable( INTS_ALL );
   \   000005                ; Setup parameters for call to function osal_int_disable
   \   000005   79FF         MOV     R1,#-0x1
   \   000007   12....       LCALL   `??osal_int_disable::?relay`; Banked call to: osal_int_disable
    148          
    149            // Initialization for board related stuff such as LEDs
    150            HAL_BOARD_INIT();
   \   00000A   53BEFB       ANL     0xbe,#0xfb
   \                     ??main_0:
   \   00000D   E59D         MOV     A,0x9d
   \   00000F   A2E6         MOV     C,0xE0 /* A   */.6
   \   000011   50FA         JNC     ??main_0
   \   000013   00           NOP
   \   000014   78F8         MOV     R0,#-0x8
   \   000016   7901         MOV     R1,#0x1
   \                     ??main_1:
   \   000018   00           NOP
   \   000019   E8           MOV     A,R0
   \   00001A   24FF         ADD     A,#-0x1
   \   00001C   18           DEC     R0
   \   00001D   E9           MOV     A,R1
   \   00001E   34FF         ADDC    A,#-0x1
   \   000020   F9           MOV     R1,A
   \   000021   E8           MOV     A,R0
   \   000022   49           ORL     A,R1
   \   000023   70F3         JNZ     ??main_1
   \   000025   75C600       MOV     0xc6,#0x0
   \                     ??main_2:
   \   000028   E59E         MOV     A,0x9e
   \   00002A   70FC         JNZ     ??main_2
   \   00002C   43BE04       ORL     0xbe,#0x4
   \   00002F   906270       MOV     DPTR,#0x6270
   \   000032   7408         MOV     A,#0x8
   \   000034   F0           MOVX    @DPTR,A
   \   000035   C290         CLR     0x90.0
   \   000037   43FE01       ORL     0xfe,#0x1
   \   00003A   C291         CLR     0x90.1
   \   00003C   43FE02       ORL     0xfe,#0x2
   \   00003F   C294         CLR     0x90.4
   \   000041   43FE10       ORL     0xfe,#0x10
   \   000044   438F01       ORL     0x8f,#0x1
    151          
    152          #if  (MOTION_SENSOR || MAGNETIC_SENSOR)
    153            
    154            //Initialization for pins for magnetic switch
    155            //and initilization for motion sensor pins
    156            magneticSwitchInit();
    157          
    158            //Initialization for analog to digital converter
    159            HalAdcInit();
    160          #endif
    161            
    162          //#if BME280_SENSOR  
    163            
    164            //Initialization of SPI
    165            Hal_SPI_Master_Init();
   \   000047                ; Setup parameters for call to function Hal_SPI_Master_Init
   \   000047   12....       LCALL   `??Hal_SPI_Master_Init::?relay`; Banked call to: Hal_SPI_Master_Init
    166          //#endif
    167          
    168            // Make sure supply voltage is high enough to run
    169            zmain_vdd_check();
   \   00004A   7E10         MOV     R6,#0x10
   \                     ??main_3:
   \   00004C                ; Setup parameters for call to function HalAdcCheckVdd
   \   00004C   794A         MOV     R1,#0x4a
   \   00004E   12....       LCALL   `??HalAdcCheckVdd::?relay`; Banked call to: HalAdcCheckVdd
   \   000051   E9           MOV     A,R1
   \   000052   60F8         JZ      ??main_3
   \   000054   1E           DEC     R6
   \   000055   EE           MOV     A,R6
   \   000056   70F4         JNZ     ??main_3
    170          
    171            // Initialize board I/O
    172          //  InitBoard( OB_COLD ); //za interapte (magetik i motion)
    173          
    174            // Initialze HAL drivers
    175            HalDriverInit();
   \   000058                ; Setup parameters for call to function HalDriverInit
   \   000058   12....       LCALL   `??HalDriverInit::?relay`; Banked call to: HalDriverInit
    176            
    177          
    178            // Initialize NV System
    179            osal_nv_init( NULL );
   \   00005B                ; Setup parameters for call to function osal_nv_init
   \   00005B   7A00         MOV     R2,#0x0
   \   00005D   7B00         MOV     R3,#0x0
   \   00005F   12....       LCALL   `??osal_nv_init::?relay`; Banked call to: osal_nv_init
    180          
    181            // Initialize the MAC
    182            ZMacInit();
   \   000062                ; Setup parameters for call to function ZMacInit
   \   000062   12....       LCALL   `??ZMacInit::?relay` ; Banked call to: ZMacInit
    183          
    184            // Determine the extended address
    185            zmain_ext_addr();
   \   000065                ; Setup parameters for call to function zmain_ext_addr
   \   000065   12....       LCALL   `??zmain_ext_addr::?relay`; Banked call to: zmain_ext_addr
    186          
    187          #if defined ZCL_KEY_ESTABLISH
    188            // Initialize the Certicom certificate information.
    189            zmain_cert_init();
    190          #endif
    191          
    192            // Initialize basic NV items
    193            zgInit();
   \   000068                ; Setup parameters for call to function zgInit
   \   000068   12....       LCALL   `??zgInit::?relay`   ; Banked call to: zgInit
    194          
    195          #ifndef NONWK
    196            // Since the AF isn't a task, call it's initialization routine
    197            afInit();
    198          #endif
    199          
    200            // Initialize the operating system
    201            osal_init_system();
   \   00006B                ; Setup parameters for call to function osal_init_system
   \   00006B   12....       LCALL   `??osal_init_system::?relay`; Banked call to: osal_init_system
    202          
    203            // Allow interrupts
    204            osal_int_enable( INTS_ALL );
   \   00006E                ; Setup parameters for call to function osal_int_enable
   \   00006E   79FF         MOV     R1,#-0x1
   \   000070   12....       LCALL   `??osal_int_enable::?relay`; Banked call to: osal_int_enable
    205            
    206          #if (MOTION_SENSOR || MAGNETIC_SENSOR)
    207            // Final board initialization
    208            InitBoard( OB_READY );
    209          #endif
    210            // Display information about this device
    211            zmain_dev_info();
   \   000073   7A..         MOV     R2,#(aExtendedAddress + 7) & 0xff
   \   000075   7B..         MOV     R3,#((aExtendedAddress + 7) >> 8) & 0xff
   \   000077   7C00         MOV     R4,#0x0
   \                     ??main_4:
   \   000079   8A82         MOV     DPL,R2
   \   00007B   8B83         MOV     DPH,R3
   \   00007D   E0           MOVX    A,@DPTR
   \   00007E   C4           SWAP    A
   \   00007F   540F         ANL     A,#0xf
   \   000081   FD           MOV     R5,A
   \   000082   EC           MOV     A,R4
   \   000083   FE           MOV     R6,A
   \   000084   7401         MOV     A,#0x1
   \   000086   2E           ADD     A,R6
   \   000087   FC           MOV     R4,A
   \   000088   ED           MOV     A,R5
   \   000089   C3           CLR     C
   \   00008A   940A         SUBB    A,#0xa
   \   00008C   5004         JNC     ??main_5
   \   00008E   7830         MOV     R0,#0x30
   \   000090   8002         SJMP    ??main_6
   \                     ??main_5:
   \   000092   7837         MOV     R0,#0x37
   \                     ??main_6:
   \   000094   E8           MOV     A,R0
   \   000095   2D           ADD     A,R5
   \   000096   C0E0         PUSH    A
   \   000098   85..82       MOV     DPL,?XSP + 0
   \   00009B   85..83       MOV     DPH,?XSP + 1
   \   00009E   E582         MOV     A,DPL
   \   0000A0   2E           ADD     A,R6
   \   0000A1   F582         MOV     DPL,A
   \   0000A3   E4           CLR     A
   \   0000A4   3583         ADDC    A,DPH
   \   0000A6   F583         MOV     DPH,A
   \   0000A8   D0E0         POP     A
   \   0000AA   F0           MOVX    @DPTR,A
   \   0000AB   8A82         MOV     DPL,R2
   \   0000AD   8B83         MOV     DPH,R3
   \   0000AF   E0           MOVX    A,@DPTR
   \   0000B0   540F         ANL     A,#0xf
   \   0000B2   FD           MOV     R5,A
   \   0000B3   EC           MOV     A,R4
   \   0000B4   FF           MOV     R7,A
   \   0000B5   7401         MOV     A,#0x1
   \   0000B7   2C           ADD     A,R4
   \   0000B8   FC           MOV     R4,A
   \   0000B9   ED           MOV     A,R5
   \   0000BA   C3           CLR     C
   \   0000BB   940A         SUBB    A,#0xa
   \   0000BD   5004         JNC     ??main_7
   \   0000BF   7830         MOV     R0,#0x30
   \   0000C1   8002         SJMP    ??main_8
   \                     ??main_7:
   \   0000C3   7837         MOV     R0,#0x37
   \                     ??main_8:
   \   0000C5   E8           MOV     A,R0
   \   0000C6   2D           ADD     A,R5
   \   0000C7   C0E0         PUSH    A
   \   0000C9   85..82       MOV     DPL,?XSP + 0
   \   0000CC   85..83       MOV     DPH,?XSP + 1
   \   0000CF   E582         MOV     A,DPL
   \   0000D1   2F           ADD     A,R7
   \   0000D2   F582         MOV     DPL,A
   \   0000D4   E4           CLR     A
   \   0000D5   3583         ADDC    A,DPH
   \   0000D7   F583         MOV     DPH,A
   \   0000D9   D0E0         POP     A
   \   0000DB   F0           MOVX    @DPTR,A
   \   0000DC   EA           MOV     A,R2
   \   0000DD   24FF         ADD     A,#-0x1
   \   0000DF   EB           MOV     A,R3
   \   0000E0   34FF         ADDC    A,#-0x1
   \   0000E2   1A           DEC     R2
   \   0000E3   FB           MOV     R3,A
   \   0000E4   EC           MOV     A,R4
   \   0000E5   C3           CLR     C
   \   0000E6   9410         SUBB    A,#0x10
   \   0000E8   408F         JC      ??main_4
   \   0000EA   7410         MOV     A,#0x10
   \   0000EC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EF   E4           CLR     A
   \   0000F0   F0           MOVX    @DPTR,A
   \   0000F1                ; Setup parameters for call to function HalLcdWriteString
   \   0000F1   7901         MOV     R1,#0x1
   \   0000F3   7A..         MOV     R2,#`?<Constant "IEEE: ">` & 0xff
   \   0000F5   7B..         MOV     R3,#(`?<Constant "IEEE: ">` >> 8) & 0xff
   \   0000F7   12....       LCALL   `??HalLcdWriteString::?relay`; Banked call to: HalLcdWriteString
   \   0000FA                ; Setup parameters for call to function HalLcdWriteString
   \   0000FA   7902         MOV     R1,#0x2
   \   0000FC   AA..         MOV     R2,?XSP + 0
   \   0000FE   AB..         MOV     R3,?XSP + 1
   \   000100   12....       LCALL   `??HalLcdWriteString::?relay`; Banked call to: HalLcdWriteString
    212          
    213            /* Display the device info on the LCD */
    214          #ifdef LCD_SUPPORTED
    215            //zmain_lcd_init();
    216          #endif
    217          
    218          #ifdef WDT_IN_PM1
    219            /* If WDT is used, this is a good place to enable it. */
    220            //WatchDogEnable( WDTIMX );
    221          #endif
    222          
    223          
    224          #if BME280_SENSOR  
    225            
    226            flag = bme280_set(&bme280, &Value);
   \   000103                ; Setup parameters for call to function bme280_set
   \   000103   7C..         MOV     R4,#Value & 0xff
   \   000105   7D..         MOV     R5,#(Value >> 8) & 0xff
   \   000107   7A..         MOV     R2,#bme280 & 0xff
   \   000109   7B..         MOV     R3,#(bme280 >> 8) & 0xff
   \   00010B   12....       LCALL   `??bme280_set::?relay`; Banked call to: bme280_set
   \   00010E   8A..         MOV     ?V0,R2
   \   000110   8B..         MOV     ?V1,R3
   \   000112   8C..         MOV     ?V2,R4
   \   000114   8D..         MOV     ?V3,R5
   \   000116   EA           MOV     A,R2
   \   000117   90....       MOV     DPTR,#flag
   \   00011A   F0           MOVX    @DPTR,A
    227          
    228            for(i=0;i<100;i++)
   \   00011B   7464         MOV     A,#0x64
    229            {
    230              asm("NOP");
   \                     ??main_9:
   \   00011D   00           NOP
    231            }
   \   00011E   14           DEC     A
   \   00011F   70FC         JNZ     ??main_9
    232          
    233            if (-1 == flag)
   \   000121   E0           MOVX    A,@DPTR
   \   000122   F4           CPL     A
   \   000123   7009         JNZ     ??main_10
    234            {
    235              HalLcdWriteString("Nije dobro!",0);
   \   000125                ; Setup parameters for call to function HalLcdWriteString
   \   000125   7900         MOV     R1,#0x0
   \   000127   7A..         MOV     R2,#`?<Constant "Nije dobro!">` & 0xff
   \   000129   7B..         MOV     R3,#(`?<Constant "Nije dobro!">` >> 8) & 0xff
   \   00012B   12....       LCALL   `??HalLcdWriteString::?relay`; Banked call to: HalLcdWriteString
    236            }
    237                
    238            HalLcdWriteString("Dobro je",0);
   \                     ??main_10:
   \   00012E                ; Setup parameters for call to function HalLcdWriteString
   \   00012E   7900         MOV     R1,#0x0
   \   000130   7A..         MOV     R2,#`?<Constant "Dobro je">` & 0xff
   \   000132   7B..         MOV     R3,#(`?<Constant "Dobro je">` >> 8) & 0xff
   \   000134   12....       LCALL   `??HalLcdWriteString::?relay`; Banked call to: HalLcdWriteString
    239          
    240          #endif
    241            
    242           osal_start_system(); // No Return from here
   \   000137                ; Setup parameters for call to function osal_start_system
   \   000137   12....       LCALL   `??osal_start_system::?relay`; Banked call to: osal_start_system
    243          
    244            return 0;  // Shouldn't get here.
   \   00013A   7A00         MOV     R2,#0x0
   \   00013C   7B00         MOV     R3,#0x0
   \   00013E   7411         MOV     A,#0x11
   \   000140   12....       LCALL   ?DEALLOC_XSTACK8
   \   000143   02....       LJMP    ?BRET
   \   000146                REQUIRE SLEEPCMD
   \   000146                REQUIRE SLEEPSTA
   \   000146                REQUIRE CLKCONCMD
   \   000146                REQUIRE CLKCONSTA
   \   000146                REQUIRE _A_P1
   \   000146                REQUIRE P1DIR
   \   000146                REQUIRE P0INP
    245          } // main()
    246          
    247          /*********************************************************************
    248           * @fn      zmain_vdd_check
    249           * @brief   Check if the Vdd is OK to run the processor.
    250           * @return  Return if Vdd is ok; otherwise, flash LED, then reset
    251           *********************************************************************/
    252          static void zmain_vdd_check( void )
    253          {
    254            uint8 cnt = 16;
    255          
    256            do {
    257              while (!HalAdcCheckVdd(VDD_MIN_RUN));
    258            } while (--cnt);
    259          }
    260          
    261          /**************************************************************************************************
    262           * @fn          zmain_ext_addr
    263           *
    264           * @brief       Execute a prioritized search for a valid extended address and write the results
    265           *              into the OSAL NV system for use by the system. Temporary address not saved to NV.
    266           *
    267           * input parameters
    268           *
    269           * None.
    270           *
    271           * output parameters
    272           *
    273           * None.
    274           *
    275           * @return      None.
    276           **************************************************************************************************
    277           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    278          static void zmain_ext_addr(void)
   \                     zmain_ext_addr:
    279          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    280            uint8 nullAddr[Z_EXTADDR_LEN] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
   \   00000A   90....       MOV     DPTR,#`?<Constant {255, 255, 255, 255, 255, 255, 255,`
   \   00000D   AC..         MOV     R4,?XSP + 0
   \   00000F   AD..         MOV     R5,?XSP + 1
   \   000011   7408         MOV     A,#0x8
   \   000013   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    281            uint8 writeNV = TRUE;
    282          
    283            // First check whether a non-erased extended address exists in the OSAL NV.
    284            if ((SUCCESS != osal_nv_item_init(ZCD_NV_EXTADDR, Z_EXTADDR_LEN, NULL))  ||
    285                (SUCCESS != osal_nv_read(ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, aExtendedAddress)) ||
    286                (osal_memcmp(aExtendedAddress, nullAddr, Z_EXTADDR_LEN)))
   \   000016                ; Setup parameters for call to function osal_nv_item_init
   \   000016   F5..         MOV     ?V0,A
   \   000018   F5..         MOV     ?V1,A
   \   00001A   78..         MOV     R0,#?V0
   \   00001C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001F   7C08         MOV     R4,#0x8
   \   000021   7D00         MOV     R5,#0x0
   \   000023   7A01         MOV     R2,#0x1
   \   000025   7B00         MOV     R3,#0x0
   \   000027   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   00002A   7402         MOV     A,#0x2
   \   00002C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00002F   E9           MOV     A,R1
   \   000030   7051         JNZ     ??zmain_ext_addr_0
   \   000032                ; Setup parameters for call to function osal_nv_read
   \   000032   75....       MOV     ?V0,#aExtendedAddress & 0xff
   \   000035   75....       MOV     ?V1,#(aExtendedAddress >> 8) & 0xff
   \   000038   78..         MOV     R0,#?V0
   \   00003A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003D   75..08       MOV     ?V0,#0x8
   \   000040   75..00       MOV     ?V1,#0x0
   \   000043   78..         MOV     R0,#?V0
   \   000045   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000048   7C00         MOV     R4,#0x0
   \   00004A   7D00         MOV     R5,#0x0
   \   00004C   7A01         MOV     R2,#0x1
   \   00004E   7B00         MOV     R3,#0x0
   \   000050   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000053   7404         MOV     A,#0x4
   \   000055   12....       LCALL   ?DEALLOC_XSTACK8
   \   000058   E9           MOV     A,R1
   \   000059   7028         JNZ     ??zmain_ext_addr_0
   \   00005B                ; Setup parameters for call to function osal_memcmp
   \   00005B   A8..         MOV     R0,?XSP + 0
   \   00005D   A9..         MOV     R1,?XSP + 1
   \   00005F   88..         MOV     ?V0,R0
   \   000061   89..         MOV     ?V1,R1
   \   000063   75..00       MOV     ?V2,#0x0
   \   000066   78..         MOV     R0,#?V0
   \   000068   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00006B   7C08         MOV     R4,#0x8
   \   00006D   7D00         MOV     R5,#0x0
   \   00006F   79..         MOV     R1,#aExtendedAddress & 0xff
   \   000071   7A..         MOV     R2,#(aExtendedAddress >> 8) & 0xff
   \   000073   7B00         MOV     R3,#0x0
   \   000075   12....       LCALL   `??osal_memcmp::?relay`; Banked call to: osal_memcmp
   \   000078   7403         MOV     A,#0x3
   \   00007A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007D   E9           MOV     A,R1
   \   00007E   7003         JNZ     $+5
   \   000080   02....       LJMP    ??zmain_ext_addr_1 & 0xFFFF
    287            {
    288              // Attempt to read the extended address from the location on the lock bits page
    289              // where the programming tools know to reserve it.
    290              HalFlashRead(HAL_FLASH_IEEE_PAGE, HAL_FLASH_IEEE_OSET, aExtendedAddress, Z_EXTADDR_LEN);
   \                     ??zmain_ext_addr_0:
   \   000083                ; Setup parameters for call to function HalFlashRead
   \   000083   75..08       MOV     ?V0,#0x8
   \   000086   75..00       MOV     ?V1,#0x0
   \   000089   78..         MOV     R0,#?V0
   \   00008B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008E   7C..         MOV     R4,#aExtendedAddress & 0xff
   \   000090   7D..         MOV     R5,#(aExtendedAddress >> 8) & 0xff
   \   000092   7AE8         MOV     R2,#-0x18
   \   000094   7B07         MOV     R3,#0x7
   \   000096   797F         MOV     R1,#0x7f
   \   000098   12....       LCALL   `??HalFlashRead::?relay`; Banked call to: HalFlashRead
   \   00009B   7402         MOV     A,#0x2
   \   00009D   12....       LCALL   ?DEALLOC_XSTACK8
    291          
    292              if (osal_memcmp(aExtendedAddress, nullAddr, Z_EXTADDR_LEN))
   \   0000A0                ; Setup parameters for call to function osal_memcmp
   \   0000A0   A8..         MOV     R0,?XSP + 0
   \   0000A2   A9..         MOV     R1,?XSP + 1
   \   0000A4   88..         MOV     ?V0,R0
   \   0000A6   89..         MOV     ?V1,R1
   \   0000A8   75..00       MOV     ?V2,#0x0
   \   0000AB   78..         MOV     R0,#?V0
   \   0000AD   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000B0   7C08         MOV     R4,#0x8
   \   0000B2   7D00         MOV     R5,#0x0
   \   0000B4   79..         MOV     R1,#aExtendedAddress & 0xff
   \   0000B6   7A..         MOV     R2,#(aExtendedAddress >> 8) & 0xff
   \   0000B8   7B00         MOV     R3,#0x0
   \   0000BA   12....       LCALL   `??osal_memcmp::?relay`; Banked call to: osal_memcmp
   \   0000BD   7403         MOV     A,#0x3
   \   0000BF   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C2   E9           MOV     A,R1
   \   0000C3   6035         JZ      ??zmain_ext_addr_2
    293              {
    294                // Attempt to read the extended address from the designated location in the Info Page.
    295                if (!osal_memcmp((uint8 *)(P_INFOPAGE+HAL_INFOP_IEEE_OSET), nullAddr, Z_EXTADDR_LEN))
   \   0000C5                ; Setup parameters for call to function osal_memcmp
   \   0000C5   78..         MOV     R0,#?V0
   \   0000C7   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000CA   7C08         MOV     R4,#0x8
   \   0000CC   7D00         MOV     R5,#0x0
   \   0000CE   790C         MOV     R1,#0xc
   \   0000D0   7A78         MOV     R2,#0x78
   \   0000D2   7B00         MOV     R3,#0x0
   \   0000D4   12....       LCALL   `??osal_memcmp::?relay`; Banked call to: osal_memcmp
   \   0000D7   7403         MOV     A,#0x3
   \   0000D9   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000DC   E9           MOV     A,R1
   \   0000DD   7054         JNZ     ??zmain_ext_addr_3
    296                {
    297                  osal_memcpy(aExtendedAddress, (uint8 *)(P_INFOPAGE+HAL_INFOP_IEEE_OSET), Z_EXTADDR_LEN);
   \   0000DF                ; Setup parameters for call to function osal_memcpy
   \   0000DF   75..0C       MOV     ?V0,#0xc
   \   0000E2   75..78       MOV     ?V1,#0x78
   \   0000E5   78..         MOV     R0,#?V0
   \   0000E7   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000EA   7C08         MOV     R4,#0x8
   \   0000EC   7D00         MOV     R5,#0x0
   \   0000EE   7A..         MOV     R2,#aExtendedAddress & 0xff
   \   0000F0   7B..         MOV     R3,#(aExtendedAddress >> 8) & 0xff
   \   0000F2   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000F5   7403         MOV     A,#0x3
   \   0000F7   12....       LCALL   ?DEALLOC_XSTACK8
    298                }
    299                else  // No valid extended address was found.
    300                {
    301                  uint8 idx;
    302          
    303          #if !defined ( NV_RESTORE )
    304                  writeNV = FALSE;  // Make this a temporary IEEE address
    305          #endif
    306          
    307                  /* Attempt to create a sufficiently random extended address for expediency.
    308                   * Note: this is only valid/legal in a test environment and
    309                   *       must never be used for a commercial product.
    310                   */
    311                  for (idx = 0; idx < (Z_EXTADDR_LEN - 2);)
    312                  {
    313                    uint16 randy = osal_rand();
    314                    aExtendedAddress[idx++] = LO_UINT16(randy);
    315                    aExtendedAddress[idx++] = HI_UINT16(randy);
    316                  }
    317                  // Next-to-MSB identifies ZigBee devicetype.
    318          #if ZG_BUILD_COORDINATOR_TYPE && !ZG_BUILD_JOINING_TYPE
    319                  aExtendedAddress[idx++] = 0x10;
    320          #elif ZG_BUILD_RTRONLY_TYPE
    321                  aExtendedAddress[idx++] = 0x20;
    322          #else
    323                  aExtendedAddress[idx++] = 0x30;
    324          #endif
    325                  // MSB has historical signficance.
    326                  aExtendedAddress[idx] = 0xF8;
    327                }
    328              }
    329          
    330              if (writeNV)
    331              {
    332                (void)osal_nv_write(ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, aExtendedAddress);
   \                     ??zmain_ext_addr_2:
   \   0000FA                ; Setup parameters for call to function osal_nv_write
   \   0000FA   75....       MOV     ?V0,#aExtendedAddress & 0xff
   \   0000FD   75....       MOV     ?V1,#(aExtendedAddress >> 8) & 0xff
   \   000100   78..         MOV     R0,#?V0
   \   000102   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000105   75..08       MOV     ?V0,#0x8
   \   000108   75..00       MOV     ?V1,#0x0
   \   00010B   78..         MOV     R0,#?V0
   \   00010D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000110   7C00         MOV     R4,#0x0
   \   000112   7D00         MOV     R5,#0x0
   \   000114   7A01         MOV     R2,#0x1
   \   000116   7B00         MOV     R3,#0x0
   \   000118   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   00011B   7404         MOV     A,#0x4
   \   00011D   12....       LCALL   ?DEALLOC_XSTACK8
    333              }
    334            }
    335          
    336            // Set the MAC PIB extended address according to results from above.
    337            (void)ZMacSetReq(MAC_EXTENDED_ADDRESS, aExtendedAddress);
   \                     ??zmain_ext_addr_1:
   \   000120                ; Setup parameters for call to function ZMacSetReq
   \   000120   7A..         MOV     R2,#aExtendedAddress & 0xff
   \   000122   7B..         MOV     R3,#(aExtendedAddress >> 8) & 0xff
   \   000124   79E2         MOV     R1,#-0x1e
   \   000126   12....       LCALL   `??ZMacSetReq::?relay`; Banked call to: ZMacSetReq
    338          }
   \   000129   7408         MOV     A,#0x8
   \   00012B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00012E   7F03         MOV     R7,#0x3
   \   000130   02....       LJMP    ?BANKED_LEAVE_XDATA
   \                     ??zmain_ext_addr_3:
   \   000133   7E00         MOV     R6,#0x0
   \                     ??zmain_ext_addr_4:
   \   000135                ; Setup parameters for call to function osal_rand
   \   000135   12....       LCALL   `??osal_rand::?relay`; Banked call to: osal_rand
   \   000138   8A..         MOV     ?V0,R2
   \   00013A   EE           MOV     A,R6
   \   00013B   FA           MOV     R2,A
   \   00013C   74..         MOV     A,#aExtendedAddress & 0xff
   \   00013E   2A           ADD     A,R2
   \   00013F   F582         MOV     DPL,A
   \   000141   E4           CLR     A
   \   000142   34..         ADDC    A,#(aExtendedAddress >> 8) & 0xff
   \   000144   F583         MOV     DPH,A
   \   000146   E5..         MOV     A,?V0
   \   000148   F0           MOVX    @DPTR,A
   \   000149   0E           INC     R6
   \   00014A   EE           MOV     A,R6
   \   00014B   F8           MOV     R0,A
   \   00014C   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   00014F   EB           MOV     A,R3
   \   000150   F0           MOVX    @DPTR,A
   \   000151   0E           INC     R6
   \   000152   EE           MOV     A,R6
   \   000153   C3           CLR     C
   \   000154   9406         SUBB    A,#0x6
   \   000156   40DD         JC      ??zmain_ext_addr_4
   \   000158   08           INC     R0
   \   000159   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   00015C   7430         MOV     A,#0x30
   \   00015E   F0           MOVX    @DPTR,A
   \   00015F   08           INC     R0
   \   000160   74..         MOV     A,#aExtendedAddress & 0xff
   \   000162   28           ADD     A,R0
   \   000163   F582         MOV     DPL,A
   \   000165   E4           CLR     A
   \   000166   34..         ADDC    A,#(aExtendedAddress >> 8) & 0xff
   \   000168   F583         MOV     DPH,A
   \   00016A   74F8         MOV     A,#-0x8
   \   00016C   F0           MOVX    @DPTR,A
   \   00016D   80B1         SJMP    ??zmain_ext_addr_1

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   74..         MOV     A,#aExtendedAddress & 0xff
   \   000002   2E           ADD     A,R6
   \   000003   F582         MOV     DPL,A
   \   000005   E4           CLR     A
   \   000006   34..         ADDC    A,#(aExtendedAddress >> 8) & 0xff
   \   000008   F583         MOV     DPH,A
   \   00000A   22           RET

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??WriteHex::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    WriteHex

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??main::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    main

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??zmain_ext_addr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    zmain_ext_addr

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {0, 0, 0}>`:
   \   000000   00           DB 0
   \   000001   00           DB 0
   \   000002   00           DB 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Nije dobro!">`:
   \   000000   4E696A65     DB "Nije dobro!"
   \            20646F62
   \            726F2100

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Dobro je">`:
   \   000000   446F6272     DB "Dobro je"
   \            6F206A65
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {255, 255, 255, 255, 255, 255, 255,`:
   \   000000   FF           DB 255
   \   000001   FF           DB 255
   \   000002   FF           DB 255
   \   000003   FF           DB 255
   \   000004   FF           DB 255
   \   000005   FF           DB 255
   \   000006   FF           DB 255
   \   000007   FF           DB 255

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "IEEE: ">`:
   \   000000   49454545     DB "IEEE: "
   \            3A2000  
    339          
    340          #if defined ZCL_KEY_ESTABLISH
    341          /**************************************************************************************************
    342           * @fn          zmain_cert_init
    343           *
    344           * @brief       Initialize the Certicom certificate information.
    345           *
    346           * input parameters
    347           *
    348           * None.
    349           *
    350           * output parameters
    351           *
    352           * None.
    353           *
    354           * @return      None.
    355           **************************************************************************************************
    356           */
    357          static void zmain_cert_init(void)
    358          {
    359            uint8 certData[ZCL_KE_IMPLICIT_CERTIFICATE_LEN];
    360            uint8 nullData[ZCL_KE_IMPLICIT_CERTIFICATE_LEN] = {
    361              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    362              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    363              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    364              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    365              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    366              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
    367            };
    368          
    369            (void)osal_nv_item_init(ZCD_NV_IMPLICIT_CERTIFICATE, ZCL_KE_IMPLICIT_CERTIFICATE_LEN, NULL);
    370            (void)osal_nv_item_init(ZCD_NV_DEVICE_PRIVATE_KEY, ZCL_KE_DEVICE_PRIVATE_KEY_LEN, NULL);
    371          
    372            // First check whether non-null certificate data exists in the OSAL NV. To save on code space,
    373            // just use the ZCD_NV_CA_PUBLIC_KEY as the bellwether for all three.
    374            if ((SUCCESS != osal_nv_item_init(ZCD_NV_CA_PUBLIC_KEY, ZCL_KE_CA_PUBLIC_KEY_LEN, NULL))    ||
    375                (SUCCESS != osal_nv_read(ZCD_NV_CA_PUBLIC_KEY, 0, ZCL_KE_CA_PUBLIC_KEY_LEN, certData))  ||
    376                (osal_memcmp(certData, nullData, ZCL_KE_CA_PUBLIC_KEY_LEN)))
    377            {
    378              // Attempt to read the certificate data from its corresponding location on the lock bits page.
    379              HalFlashRead(HAL_FLASH_IEEE_PAGE, HAL_FLASH_CA_PUBLIC_KEY_OSET, certData,
    380                                                   ZCL_KE_CA_PUBLIC_KEY_LEN);
    381              // If the certificate data is not NULL, use it to update the corresponding NV items.
    382              if (!osal_memcmp(certData, nullData, ZCL_KE_CA_PUBLIC_KEY_LEN))
    383              {
    384                (void)osal_nv_write(ZCD_NV_CA_PUBLIC_KEY, 0, ZCL_KE_CA_PUBLIC_KEY_LEN, certData);
    385                HalFlashRead(HAL_FLASH_IEEE_PAGE, HAL_FLASH_IMPLICIT_CERT_OSET, certData,
    386                                                     ZCL_KE_IMPLICIT_CERTIFICATE_LEN);
    387                (void)osal_nv_write(ZCD_NV_IMPLICIT_CERTIFICATE, 0,
    388                                    ZCL_KE_IMPLICIT_CERTIFICATE_LEN, certData);
    389                HalFlashRead(HAL_FLASH_IEEE_PAGE, HAL_FLASH_DEV_PRIVATE_KEY_OSET, certData,
    390                                                  ZCL_KE_DEVICE_PRIVATE_KEY_LEN);
    391                (void)osal_nv_write(ZCD_NV_DEVICE_PRIVATE_KEY, 0, ZCL_KE_DEVICE_PRIVATE_KEY_LEN, certData);
    392              }
    393            }
    394          }
    395          #endif
    396          
    397          /**************************************************************************************************
    398           * @fn          zmain_dev_info
    399           *
    400           * @brief       This displays the IEEE (MSB to LSB) on the LCD.
    401           *
    402           * input parameters
    403           *
    404           * None.
    405           *
    406           * output parameters
    407           *
    408           * None.
    409           *
    410           * @return      None.
    411           **************************************************************************************************
    412           */
    413          static void zmain_dev_info(void)
    414          {
    415          #ifdef LCD_SUPPORTED
    416            uint8 i;
    417            uint8 *xad;
    418            uint8 lcd_buf[Z_EXTADDR_LEN*2+1];
    419          
    420            // Display the extended address.
    421            xad = aExtendedAddress + Z_EXTADDR_LEN - 1;
    422          
    423            for (i = 0; i < Z_EXTADDR_LEN*2; xad--)
    424            {
    425              uint8 ch;
    426              ch = (*xad >> 4) & 0x0F;
    427              lcd_buf[i++] = ch + (( ch < 10 ) ? '0' : '7');
    428              ch = *xad & 0x0F;
    429              lcd_buf[i++] = ch + (( ch < 10 ) ? '0' : '7');
    430            }
    431            lcd_buf[Z_EXTADDR_LEN*2] = '\0';
    432            HalLcdWriteString( "IEEE: ", HAL_LCD_LINE_1 );
    433            HalLcdWriteString( (char*)lcd_buf, HAL_LCD_LINE_2 );
    434          #endif
    435          }
    436          
    437          #ifdef LCD_SUPPORTED
    438          /*********************************************************************
    439           * @fn      zmain_lcd_init
    440           * @brief   Initialize LCD at start up.
    441           * @return  none
    442           *********************************************************************/
    443          static void zmain_lcd_init ( void )
                             ^
Warning[Pe177]: function "zmain_lcd_init" was declared but never referenced

  static struct bme280_t *p_bme280; 
                          ^
"C:\Users\bsavanovic\Desktop\EndDevice\ZigBeeEndDevice\Projects\zstack\ZMain\TI2530DB\ZMain.c",138  Warning[Pe177]: 
          variable "p_bme280" was declared but never referenced
    444          {
    445          #ifdef SERIAL_DEBUG_SUPPORTED
    446            {
    447              HalLcdWriteString( "TexasInstruments", HAL_LCD_LINE_1 );
    448          
    449          #if defined( MT_MAC_FUNC )
    450          #if defined( ZDO_COORDINATOR )
    451                HalLcdWriteString( "MAC-MT Coord", HAL_LCD_LINE_2 );
    452          #else
    453                HalLcdWriteString( "MAC-MT Device", HAL_LCD_LINE_2 );
    454          #endif // ZDO
    455          #elif defined( MT_NWK_FUNC )
    456          #if defined( ZDO_COORDINATOR )
    457                HalLcdWriteString( "NWK Coordinator", HAL_LCD_LINE_2 );
    458          #else
    459                HalLcdWriteString( "NWK Device", HAL_LCD_LINE_2 );
    460          #endif // ZDO
    461          #endif // MT_FUNC
    462            }
    463          #endif // SERIAL_DEBUG_SUPPORTED
    464          }
    465          #endif
    466          
    467          /*
    468          void tempCheck(struct value *val)
    469          {
    470          	if (T_MIN > val->temp / 100)
    471          	{
    472          		GPIO_PORTE_DATA_R |= 0x02;
    473          	}// end if
    474          	else if (T_MAX < val->temp / 100)
    475          		{
    476          			GPIO_PORTE_DATA_R |= 0x04;
    477          		}// end else if
    478          	else {
    479          	GPIO_PORTE_DATA_R = 0x00;
    480          	}
    481          }// end void tempCheck(struct bme280_t *bme280)
    482          
    483          */
    484          
    485          /*********************************************************************
    486          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1     12   WriteHex
        0     12   -> HalLcdWriteString
      1     17   main
        0     17   -> HalAdcCheckVdd
        0     17   -> HalDriverInit
        0     17   -> HalLcdWriteString
        0     17   -> Hal_SPI_Master_Init
        0     17   -> ZMacInit
        0     17   -> bme280_set
        0     17   -> osal_init_system
        0     17   -> osal_int_disable
        0     17   -> osal_int_enable
        0     17   -> osal_nv_init
        0     17   -> osal_start_system
        0     17   -> zgInit
        0     17   -> zmain_ext_addr
      1     40   zmain_ext_addr
        0     21   -> HalFlashRead
        0     19   -> ZMacSetReq
        0     22   -> osal_memcmp
        0     22   -> osal_memcpy
        0     21   -> osal_nv_item_init
        0     23   -> osal_nv_read
        0     23   -> osal_nv_write
        0     19   -> osal_rand


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       9  ?<Constant "Dobro je">
       7  ?<Constant "IEEE: ">
      12  ?<Constant "Nije dobro!">
       3  ?<Constant {0, 0, 0}>
       8  ?<Constant {255, 255, 255, 255, 255, 255, 255,
      11  ?Subroutine0
       1  CLKCONCMD
       1  CLKCONSTA
       1  P0INP
       1  P1DIR
       1  SLEEPCMD
       1  SLEEPSTA
      12  Value
      77  WriteHex
       6  WriteHex::?relay
       1  _A_P1
      51  bme280
       1  flag
     326  main
       6  main::?relay
     367  zmain_ext_addr
       6  zmain_ext_addr::?relay

 
 781 bytes in segment BANKED_CODE
  18 bytes in segment BANK_RELAYS
   7 bytes in segment SFR_AN
  39 bytes in segment XDATA_ROM_C
  64 bytes in segment XDATA_Z
 
  18 bytes of CODE     memory
  39 bytes of CONST    memory
   0 bytes of DATA     memory (+ 7 bytes shared)
 781 bytes of HUGECODE memory
  64 bytes of XDATA    memory

Errors: none
Warnings: 6
